<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Badge Baker & Verifier</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f9; color: #333; margin: 0; padding: 20px; }
        main { max-width: 800px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        h1, h2, h3 { color: #0056b3; border-bottom: 2px solid #eef; padding-bottom: 10px; }
        section { margin-bottom: 30px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; color: #555; }
        input[type="text"], input[type="email"], input[type="date"], select, textarea { width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        button { display: inline-block; background-color: #007bff; color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        .download-link { display: inline-block; background-color: #28a745; color: white; padding: 12px 20px; text-decoration: none; border-radius: 4px; margin-top: 15px; }
        .download-link:hover { background-color: #218838; }
        pre { background-color: #eee; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-family: "Courier New", Courier, monospace; max-height: 300px; overflow-y: auto; }
        .hidden { display: none; }
        .preview-img { max-width: 200px; height: auto; border: 1px solid #ddd; padding: 5px; border-radius: 4px; margin-top: 15px; }
        .radio-group label { display: inline-block; margin-right: 15px; font-weight: normal; }
        table.summary-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        table.summary-table th, table.summary-table td { text-align: left; padding: 8px; border: 1px solid #ddd; }
        table.summary-table th { background-color: #f2f2f2; width: 120px; }
        .verification-result { margin-top: 10px; font-weight: bold; }
    </style>
</head>
<body>
    <main>
        <h1>Open Badge Baker & Verifier üèÖ</h1>
        
        <section id="config-section">
            <h2>1. Load Configuration</h2>
            <p>Attempting to load <strong>config.yaml</strong> or <strong>config.json</strong> automatically. If neither is found, please load your config file manually.</p>
            <input type="file" id="configFile" accept=".yaml,.yml,.json">
        </section>

        <section id="baker-section" class="hidden">
            <h2>2. Issue a Badge</h2>
            <form id="baker-form">
                <label for="badge-select">Select Badge:</label>
                <select id="badge-select" required></select>

                <label for="recipient-email">Recipient Email:</label>
                <input type="email" id="recipient-email" placeholder="jane.doe@example.com" required>

                <label for="issued-date">Issue Date:</label>
                <input type="date" id="issued-date" required>
                
                <label>Expiration:</label>
                <div class="radio-group">
                    <label><input type="radio" name="expiration" value="no" checked> No Expiration</label>
                    <label><input type="radio" name="expiration" value="yes"> Set Date</label>
                </div>
                <input type="date" id="expires-date" class="hidden">

                <button type="submit">Bake Badge</button>
            </form>
        </section>

        <section id="result-section" class="hidden">
            <h2>3. Download Your Baked Badge</h2>
            <p>Your badge has been baked successfully.</p>
            <img id="preview-img" class="preview-img" alt="Baked Badge Preview">
            <br>
            <a id="download-link" class="download-link" href="#" download="baked-badge.png">Download Baked Badge</a>
            <h3>Generated Assertion JSON:</h3>
            <pre><code id="json-output"></code></pre>
        </section>
        
        <hr>

        <section id="verifier-section">
            <h2>Badge Verifier</h2>
            <p>Upload a baked PNG badge to check its metadata.</p>
            <input type="file" id="verifyFile" accept=".png">
            
            <div id="verify-summary" class="hidden">
                <h3>Badge Summary</h3>
                <div id="verify-summary-table"></div>
                
                <h3>Verify Recipient</h3>
                <input type="email" id="verify-email-input" placeholder="Enter recipient's email to verify identity">
                <button id="verify-recipient-btn">Verify Recipient</button>
                <div id="recipient-verification-result" class="verification-result"></div>
                
                <button id="toggle-json-btn" style="margin-top: 15px;">Show Full Assertion</button>
            </div>
            <pre id="verify-output" class="hidden"></pre>
        </section>
    </main>

    <script>
        // --- DOM Elements ---
        const configFile = document.getElementById('configFile');
        const configSection = document.getElementById('config-section');
        const bakerSection = document.getElementById('baker-section');
        const resultSection = document.getElementById('result-section');
        const bakerForm = document.getElementById('baker-form');
        const badgeSelect = document.getElementById('badge-select');
        const jsonOutput = document.getElementById('json-output');
        const previewImg = document.getElementById('preview-img');
        const downloadLink = document.getElementById('download-link');
        const issuedDateInput = document.getElementById('issued-date');
        const expirationRadios = document.querySelectorAll('input[name="expiration"]');
        const expiresDateInput = document.getElementById('expires-date');
        const verifyFile = document.getElementById('verifyFile');
        const verifySummary = document.getElementById('verify-summary');
        const verifySummaryTable = document.getElementById('verify-summary-table');
        const verifyOutput = document.getElementById('verify-output');
        const verifyEmailInput = document.getElementById('verify-email-input');
        const verifyRecipientBtn = document.getElementById('verify-recipient-btn');
        const recipientVerificationResult = document.getElementById('recipient-verification-result');
        const toggleJsonBtn = document.getElementById('toggle-json-btn');
        
        let config = {};
        let currentAssertionData = null; // Store data for verifier

        // --- Event Listeners ---
        window.addEventListener('DOMContentLoaded', async () => {
            document.getElementById('issued-date').valueAsDate = new Date();
            try {
                const response = await fetch('config.yaml');
                if (!response.ok) throw new Error('YAML not found');
                const yamlText = await response.text();
                processConfig(yamlText, 'yaml');
            } catch (error) {
                try {
                    const response = await fetch('config.json');
                    if (!response.ok) throw new Error('JSON not found');
                    const jsonText = await response.text();
                    processConfig(jsonText, 'json');
                } catch (error2) {
                    console.info("Neither config.yaml nor config.json found. Waiting for manual upload.");
                }
            }
        });
        
        configFile.addEventListener('change', handleConfigFile);
        bakerForm.addEventListener('submit', handleBake);
        verifyFile.addEventListener('change', handleVerifyFile);
        verifyRecipientBtn.addEventListener('click', handleVerifyRecipient);
        toggleJsonBtn.addEventListener('click', () => {
             verifyOutput.classList.toggle('hidden');
        });

        expirationRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                expiresDateInput.classList.toggle('hidden', e.target.value === 'no');
            });
        });

        // --- Core Logic ---
        function processConfig(configText, type) {
            try {
                config = type === 'json' ? JSON.parse(configText) : jsyaml.load(configText);
                populateBadgeSelector();
                configSection.style.display = 'none';
                bakerSection.classList.remove('hidden');
            } catch (error) {
                alert(`Error parsing config file: ${error.message}`);
            }
        }

        function populateBadgeSelector() {
            badgeSelect.innerHTML = '';
            config.badges.forEach(badge => {
                const option = document.createElement('option');
                option.value = badge.alias;
                option.textContent = badge.name;
                badgeSelect.appendChild(option);
            });
        }

        async function handleBake(event) {
            event.preventDefault();
            const badgeAlias = badgeSelect.value;
            const recipientEmail = document.getElementById('recipient-email').value;
            const issuedDate = issuedDateInput.value;
            const expiresOption = document.querySelector('input[name="expiration"]:checked').value;
            const expiresDate = expiresOption === 'yes' ? expiresDateInput.value : null;

            if (!badgeAlias || !recipientEmail || !issuedDate || (expiresOption === 'yes' && !expiresDate)) {
                alert('Please fill out all fields.');
                return;
            }

            try {
                const badgeData = config.badges.find(b => b.alias === badgeAlias);
                const assertion = await buildAssertion(badgeData, recipientEmail, issuedDate, expiresDate);
                const bakedPngDataUri = await bakePng(badgeData.image_base_64, assertion);
                
                jsonOutput.textContent = JSON.stringify(assertion, null, 2);
                previewImg.src = bakedPngDataUri;
                downloadLink.href = bakedPngDataUri;
                downloadLink.download = `${badgeAlias}-${recipientEmail.split('@')[0]}.png`;
                
                resultSection.classList.remove('hidden');
            } catch (error) {
                alert(`Could not bake badge: ${error.message}`);
            }
        }

        async function handleVerifyFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                verifySummary.classList.add('hidden');
                verifyOutput.classList.add('hidden');
                recipientVerificationResult.textContent = '';

                try {
                    const pngBytes = new Uint8Array(e.target.result);
                    currentAssertionData = extractBadgeData(pngBytes);
                    if (currentAssertionData) {
                        displayVerificationSummary(currentAssertionData);
                        verifyOutput.textContent = JSON.stringify(currentAssertionData, null, 2);
                        verifySummary.classList.remove('hidden');
                    } else {
                        verifyOutput.textContent = 'No valid Open Badge metadata found.';
                        verifyOutput.classList.remove('hidden');
                    }
                } catch (error) {
                    verifyOutput.textContent = `Error reading badge: ${error.message}`;
                    verifyOutput.classList.remove('hidden');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function displayVerificationSummary(assertion) {
            const issuedOn = new Date(assertion.issuedOn).toLocaleDateString();
            const expiresOn = assertion.expires ? new Date(assertion.expires).toLocaleDateString() : 'Never';
            
            const tableHTML = `
                <table class="summary-table">
                    <tr><th>Badge Name</th><td>${escapeHtml(assertion.badge.name)}</td></tr>
                    <tr><th>Issued By</th><td>${escapeHtml(assertion.badge.issuer.name)}</td></tr>
                    <tr><th>Issued On</th><td>${escapeHtml(issuedOn)}</td></tr>
                    <tr><th>Expires On</th><td>${escapeHtml(expiresOn)}</td></tr>
                    <tr><th>Recipient</th><td>Hashed (verify below)</td></tr>
                </table>
            `;
            verifySummaryTable.innerHTML = tableHTML;
        }

        async function handleVerifyRecipient() {
            if (!currentAssertionData) return;
            const emailToVerify = verifyEmailInput.value;
            if (!emailToVerify) {
                recipientVerificationResult.textContent = "Please enter an email to verify.";
                return;
            }

            const { salt, identity } = currentAssertionData.recipient;
            const identityParts = identity.split('$');
            const expectedHash = identityParts.length > 1 ? identityParts[1] : identity;

            const newHashedIdentity = await hashRecipient(emailToVerify, salt);
            const newHash = newHashedIdentity.identity.split('$')[1];

            if (newHash === expectedHash) {
                recipientVerificationResult.textContent = `‚úÖ Verified for: ${escapeHtml(emailToVerify)}`;
                recipientVerificationResult.style.color = 'green';
            } else {
                recipientVerificationResult.textContent = `‚ùå Verification failed for: ${escapeHtml(emailToVerify)}`;
                recipientVerificationResult.style.color = 'red';
            }
        }
        
        async function buildAssertion(badge, email, issuedOn, expires) {
            const recipientIdentity = await hashRecipient(email);
            const assertion = {
                "@context": "https://w3id.org/openbadges/v2",
                "type": "Assertion",
                "id": `urn:uuid:${generateUUID()}`,
                "recipient": recipientIdentity,
                "badge": { /* ... badge class details ... */ },
                "issuedOn": new Date(`${issuedOn}T00:00:00Z`).toISOString(),
                "verification": { "type": "hosted" }
            };
            assertion.badge = {
                "type": "BadgeClass", "id": badge.id, "name": badge.name,
                "description": badge.description, "image": badge.image_base_64,
                "criteria": { "narrative": badge.criteria }, "issuer": config.issuer.id
            };
            if (expires) {
                assertion.expires = new Date(`${expires}T00:00:00Z`).toISOString();
            }
            return assertion;
        }
        
        // --- Helper and Utility Functions ---
        function escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }
        
        async function hashRecipient(email, salt = `salt-${Date.now()}`) {
            const identityStr = email + salt;
            const encoder = new TextEncoder();
            const data = encoder.encode(identityStr);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return { type: 'email', hashed: true, salt: salt, identity: `sha256$${hashHex}` };
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0; return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        
        function extractBadgeData(pngBytes) {
            const decoder = new TextDecoder(); let offset = 8;
            while (offset < pngBytes.length) {
                const view = new DataView(pngBytes.buffer);
                const len = view.getUint32(offset, false);
                const type = decoder.decode(pngBytes.slice(offset + 4, offset + 8));
                if (type === 'tEXt' || type === 'iTXt') {
                    const chunkData = pngBytes.slice(offset + 8, offset + 8 + len);
                    const nullIndex = chunkData.indexOf(0);
                    if (nullIndex > 0) {
                        const keyword = decoder.decode(chunkData.slice(0, nullIndex));
                        if (keyword === 'openbadges') {
                            let dataOffset = nullIndex + 1;
                            if (type === 'iTXt') {
                                dataOffset += 2; 
                                while (pngBytes[offset + 8 + dataOffset] !== 0) dataOffset++; dataOffset++;
                                while (pngBytes[offset + 8 + dataOffset] !== 0) dataOffset++; dataOffset++;
                            }
                            const assertionText = decoder.decode(chunkData.slice(dataOffset));
                            return JSON.parse(assertionText);
                        }
                    }
                }
                if (type === 'IEND') break;
                offset += 12 + len;
            }
            return null;
        }

        async function bakePng(base64Png, assertionJson) {
            const pngHeader = "data:image/png;base64,";
            const pngData = atob(base64Png.substring(pngHeader.length));
            const pngBytes = new Uint8Array(pngData.length);
            for (let i = 0; i < pngData.length; i++) pngBytes[i] = pngData.charCodeAt(i);
            
            const keyword = "openbadges"; const text = JSON.stringify(assertionJson);
            const encoder = new TextEncoder();
            const keywordBytes = encoder.encode(keyword); const textBytes = encoder.encode(text);
            const chunkData = new Uint8Array(keywordBytes.length + 1 + textBytes.length);
            chunkData.set(keywordBytes, 0); chunkData[keywordBytes.length] = 0;
            chunkData.set(textBytes, keywordBytes.length + 1);
            const chunkType = new Uint8Array([116, 69, 88, 116]);
            const chunkLength = chunkData.length;
            const fullChunk = new Uint8Array(4 + 4 + chunkLength + 4);
            const view = new DataView(fullChunk.buffer);
            view.setUint32(0, chunkLength, false);
            fullChunk.set(chunkType, 4); fullChunk.set(chunkData, 8);
            const crcData = new Uint8Array(4 + chunkLength);
            crcData.set(chunkType, 0); crcData.set(chunkData, 4);
            view.setUint32(8 + chunkLength, crc32(crcData), false);
            
            let iendOffset = -1;
            for (let i = 8; i < pngBytes.length;) {
                const len = (new DataView(pngBytes.buffer)).getUint32(i, false);
                const type = new TextDecoder().decode(pngBytes.slice(i + 4, i + 8));
                if (type === 'IEND') { iendOffset = i; break; }
                i += 12 + len;
            }
            if (iendOffset === -1) throw new Error("Could not find IEND chunk in PNG.");

            const newPngBytes = new Uint8Array(pngBytes.length + fullChunk.length);
            newPngBytes.set(pngBytes.slice(0, iendOffset), 0);
            newPngBytes.set(fullChunk, iendOffset);
            newPngBytes.set(pngBytes.slice(iendOffset), iendOffset + fullChunk.length);
            
            let newPngData = '';
            for (let i = 0; i < newPngBytes.length; i++) newPngData += String.fromCharCode(newPngBytes[i]);
            return pngHeader + btoa(newPngData);
        }

        const crcTable = (() => {
            const table = new Int32Array(256);
            for(let n = 0; n < 256; n++) {
                let c = n;
                for(let k = 0; k < 8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                table[n] = c;
            }
            return table;
        })();

        function crc32(bytes) {
            let crc = -1;
            for (let i = 0; i < bytes.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
            return (crc ^ -1) >>> 0;
        }
    </script>
</body>
</html>
