<!DOCTYPE html>
<!--
Copyright (C) 2025 KSEC - Erez Kalman. All Rights Reserved.

SPDX-License-Identifier: (AGPL-3.0-or-later OR LicenseRef-Erez_Kalman_KSEC-Commercial)

This source code is licensed under a dual-license model.
See the LICENSE, and LICENSE.AGPL.md files for full details.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Badge Management Suite</title>
    <link rel="icon" href="favicon.ico" sizes="32x32">
    <style>
        :root { --primary-color: #007bff; --primary-hover: #0056b3; --border-color: #dee2e6; --danger-color: #dc3545; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f9; color: #333; margin: 0; padding: 20px; }
        main { max-width: 900px; margin: 20px auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        h1, h2, h3, h4 { color: #0056b3; border-bottom: 2px solid #eef; padding-bottom: 10px; }
        h4 { border-bottom: 1px dashed #eef; }
        section { margin-bottom: 30px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; color: #555; }
        input[type="text"], input[type="email"], input[type="date"], input[type="password"], input[type="number"], select, textarea { width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-family: inherit; }
        textarea { min-height: 80px; font-family: "Courier New", Courier, monospace; }
        button { display: inline-block; background-color: var(--primary-color); color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; margin-right: 10px; margin-top: 5px; }
        button:hover { background-color: var(--primary-hover); }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #5a6268; }
        button.danger { background-color: var(--danger-color); }
        button.danger:hover { background-color: #c82333; }
        pre { background-color: #eee; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-family: "Courier New", Courier, monospace; max-height: 300px; overflow-y: auto; }
        .tabs { border-bottom: 2px solid var(--border-color); margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        .tabs .tab-buttons { display: flex; }
        .tabs button { background-color: transparent; border: none; padding: 10px 15px; cursor: pointer; font-size: 18px; color: #0056b3; border-bottom: 3px solid transparent; }
        .tabs button.active { border-bottom: 3px solid var(--primary-color); font-weight: bold; }
        .tabs button:disabled { color: #6c757d; cursor: not-allowed; }
        .error-message { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        .warning-message { color: #856404; background-color: #fff3cd; border: 1px solid #ffeeba; padding: 10px; border-radius: 4px; margin-top: 10px;}
        fieldset { border: 1px solid #ccc; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
        legend { font-weight: bold; color: var(--primary-color); padding: 0 10px; }
        details { margin-bottom: 10px; border: 1px solid #eee; padding: 5px; border-radius: 4px;}
        summary { cursor: pointer; font-weight: normal; color: #555; font-size: 0.9em;}
        .badge-entry { border: 1px dashed #ccc; padding: 15px; margin-bottom: 15px; border-radius: 4px; }
        .modal { position: fixed; z-index: 100; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 30px; border-radius: 8px; width: 450px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .verification-result { margin-top: 10px; font-weight: bold; }
        .input-group { position: relative; }
        .toggle-visibility { position: absolute; right: 10px; top: 10px; cursor: pointer; user-select: none; font-style: normal; }
        .image-manager { display: flex; align-items: flex-start; gap: 15px; }
        .image-manager img { max-width: 100px; height: auto; border: 1px solid #ddd; }
        .image-manager .controls { flex-grow: 1; }
        footer { text-align: center; margin-top: 30px; color: #6c757d; font-size: 0.9em; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <main>
        <h1>Open Badge Management Suite üèÖ</h1>
        
        <div class="tabs">
            <div class="tab-buttons">
                <button id="manage-tab-btn" class="active">Issuer Management</button>
                <button id="bake-tab-btn" disabled title="Load or create a configuration first">Bake a Badge</button>
                <button id="verify-tab-btn">Verify a Badge</button>
            </div>
            <button id="clear-session-btn" class="secondary hidden">Clear & Lock</button>
        </div>

        <div id="manager-view">
            <section id="config-loader-section">
                <h2>Load or Create Configuration</h2>
                <p>Load a plain or encrypted <strong>config.json</strong> file, or create a new configuration from scratch.</p>
                <input type="file" id="configFile" accept=".json">
                <button type="button" id="create-new-config-btn">Create New Config</button>
                <div id="config-error" class="error-message hidden"></div>
            </section>
            <section id="manager-form-section" class="hidden">
                <form id="manager-form">
                    <fieldset>
                        <legend>Issuer Details</legend>
                        <div id="issuer-fields"></div>
                        <button type="button" id="generate-issuer-json-btn" class="secondary">Generate Issuer JSON</button>
                    </fieldset>
                    <fieldset>
                        <legend>Badge Classes</legend>
                        <div id="badges-container"></div>
                        <button type="button" id="add-badge-btn">Add Another Badge</button>
                    </fieldset>
                    <hr>
                    <fieldset>
                        <legend>Export Options</legend>
                        <label for="kdf-iterations">PBKDF2 Iterations (for encryption):</label>
                        <input type="number" id="kdf-iterations" value="250000" min="10000">
                        <details><summary>Help</summary><p>Higher numbers increase security against brute-force attacks but make encryption/decryption slower. 250,000 is a strong default.</p></details>
                        <button type="button" id="export-plain-btn">Export as Plain JSON</button>
                        <button type="button" id="export-encrypted-btn">Export as Encrypted JSON</button>
                    </fieldset>
                </form>
            </section>
        </div>
        <div id="baker-view" class="hidden"></div>
        <div id="verifier-view" class="hidden"></div>
    </main>

    <div id="password-modal" class="modal hidden"></div>

    <template id="baker-template">
        <section>
            <h2>Issue a Badge</h2>
            <form id="baker-form">
                <div id="baker-error" class="error-message hidden"></div>
                <label for="badge-select">Select Badge:</label>
                <select id="badge-select" required></select>
                <label for="recipient-email">Recipient Email:</label>
                <input type="email" id="recipient-email" placeholder="jane.doe@example.com" required>
                <label for="evidence-url">Evidence URL (Optional):</label>
                <input type="text" id="evidence-url" placeholder="https://github.com/janedoe/project">
                <label for="issued-date">Issue Date:</label>
                <input type="date" id="issued-date" required>
                <label>Expiration:</label>
                <div><label><input type="radio" name="expiration" value="no" checked> No Expiration</label><label><input type="radio" name="expiration" value="yes"> Set Date</label></div>
                <input type="date" id="expires-date" class="hidden">
                <label>Verification Type:</label>
                <div><label><input type="radio" name="verification" value="hosted" checked> Hosted</label><label><input type="radio" name="verification" value="signed"> Signed</label></div>
                <button type="submit">Bake Badge</button>
            </form>
        </section>
        <section id="result-section" class="hidden">
            <h3>Baked Badge Result</h3>
            <img id="preview-img" style="max-width: 200px; border: 1px solid #ddd; border-radius: 4px;">
            <br>
            <a id="download-link" class="download-link" href="#" download="baked-badge.png">Download Baked Badge</a>
            <pre><code id="json-output"></code></pre>
        </section>
    </template>
    
    <template id="verifier-template">
         <section>
            <h2>Badge Verifier</h2>
            <input type="file" id="verifyFile" accept=".png">
            <div id="verify-error" class="error-message hidden"></div>
            <div id="verify-summary" class="hidden">
                <h3>Badge Summary</h3>
                <div id="verify-summary-table"></div>
                <div id="recipient-verification-section" class="hidden">
                    <h3>Verify Recipient</h3>
                    <input type="email" id="verify-email-input" placeholder="Enter recipient's email to verify identity">
                    <button id="verify-recipient-btn">Verify Recipient</button>
                    <div id="recipient-verification-result" class="verification-result"></div>
                </div>
                <button id="toggle-json-btn" style="margin-top: 15px;">Show/Hide Full Assertion</button>
            </div>
            <pre id="verify-output" class="hidden"></pre>
        </section>
    </template>

    <template id="password-modal-template">
        <div class="modal-content">
            <h3 id="modal-title">Enter Password</h3>
            <div id="modal-warning" class="warning-message hidden"></div>
            <div id="modal-error" class="error-message hidden"></div>
            <input type="password" id="modal-password" placeholder="Password">
            <input type="password" id="modal-confirm-password" placeholder="Confirm Password" class="hidden">
            <button id="modal-submit">Submit</button>
            <button id="modal-cancel" class="secondary">Cancel</button>
        </div>
    </template>
    
    <footer>(C) 2025 KSEC - Erez Kalman</footer>

    <script>
    window.addEventListener('DOMContentLoaded', () => {
        let config = null;
        let passwordModalCallback = null;
        let currentAssertionData = null;
        
        const tabs = {
            manager: { btn: document.getElementById('manage-tab-btn'), view: document.getElementById('manager-view') },
            baker:   { btn: document.getElementById('bake-tab-btn'),   view: document.getElementById('baker-view') },
            verifier:{ btn: document.getElementById('verify-tab-btn'), view: document.getElementById('verifier-view') }
        };
        const configFile = document.getElementById('configFile');
        const configLoaderSection = document.getElementById('config-loader-section');
        const managerFormSection = document.getElementById('manager-form-section');
        const createNewConfigBtn = document.getElementById('create-new-config-btn');
        const addBadgeBtn = document.getElementById('add-badge-btn');
        const exportPlainBtn = document.getElementById('export-plain-btn');
        const exportEncryptedBtn = document.getElementById('export-encrypted-btn');
        const generateIssuerJsonBtn = document.getElementById('generate-issuer-json-btn');
        const clearSessionBtn = document.getElementById('clear-session-btn');
        const passwordModal = document.getElementById('password-modal');
        const configError = document.getElementById('config-error');

        Object.values(tabs).forEach(tab => tab.btn.addEventListener('click', () => switchTab(tab.btn.id.split('-')[0])));
        configFile.addEventListener('change', handleConfigFile);
        createNewConfigBtn.addEventListener('click', createNewConfig);
        
        function initManagerFormListeners() {
            document.getElementById('add-badge-btn').addEventListener('click', () => addBadgeEntry());
            document.getElementById('export-plain-btn').addEventListener('click', handleExportPlain);
            document.getElementById('export-encrypted-btn').addEventListener('click', handleExportEncrypted);
            document.getElementById('generate-issuer-json-btn').addEventListener('click', () => generateSingleJson('issuer'));
        }
        initManagerFormListeners(); // Attach listeners for the static part of the manager form
        
        clearSessionBtn.addEventListener('click', clearSession);

        function switchTab(tabName) {
            if (tabs[tabName].btn.disabled) return;
            Object.values(tabs).forEach(tab => {
                tab.view.classList.add('hidden');
                tab.btn.classList.remove('active');
            });
            tabs[tabName].view.classList.remove('hidden');
            tabs[tabName].btn.classList.add('active');
        }
        
        function displayError(element, message) {
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function createNewConfig() {
            const defaultConfig = {
                issuer: { id: "", name: "", url: "", email: "", publicKey: "", privateKey: "" },
                badges: [{ alias: "", id: "", name: "", description: "", criteria: "", image_base_64: "", tags: "" }]
            };
            processConfig(JSON.stringify(defaultConfig));
        }

        async function handleConfigFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                displayError(configError, "Invalid file type. Please upload a JSON file.");
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const content = e.target.result;
                try {
                    const parsedJson = JSON.parse(content);
                    if (parsedJson.metadata && parsedJson.encryptedData) {
                        const password = await promptForPassword('Decrypt Configuration');
                        if (!password) return;
                        const decryptedText = await decryptData(parsedJson, password);
                        processConfig(decryptedText);
                    } else {
                        processConfig(content);
                    }
                } catch (err) {
                    displayError(configError, `Error parsing JSON file: ${err.message}`);
                }
            };
            reader.readAsText(file);
        }

        function processConfig(configText) {
            configError.classList.add('hidden');
            try {
                config = JSON.parse(configText);
                if (!config.issuer || !config.badges) throw new Error("Config must contain 'issuer' and 'badges' keys.");
                
                tabs.baker.view.innerHTML = document.getElementById('baker-template').innerHTML;
                tabs.verifier.view.innerHTML = document.getElementById('verifier-template').innerHTML;
                passwordModal.innerHTML = document.getElementById('password-modal-template').innerHTML;

                attachDynamicListeners();
                
                populateManagerForm(config);
                populateBadgeSelector(config.badges);

                configLoaderSection.classList.add('hidden');
                managerFormSection.classList.remove('hidden');
                tabs.baker.btn.disabled = false;
                tabs.baker.btn.title = "Bake a Badge";
                clearSessionBtn.classList.remove('hidden');
                switchTab('manager');
            } catch (error) {
                displayError(configError, `Error processing config file: ${error.message}`);
            }
        }

        function populateManagerForm(data) {
            document.getElementById('issuer-fields').innerHTML = createFormFields(data.issuer, 'issuer');
            document.getElementById('issuer-publicKey').after(createKeyGenButton());
            document.getElementById('generate-key-btn').addEventListener('click', generateKeyPair);
            document.getElementById('toggle-pk-visibility').addEventListener('click', togglePrivateKeyVisibility);
            document.getElementById('issuer-image_base_64-upload').addEventListener('change', (e) => handleImageUpload(e, 'issuer-image_base_64-preview', 'issuer-image_base_64'));

            const badgesContainer = document.getElementById('badges-container');
            badgesContainer.innerHTML = '';
            data.badges.forEach((badge, index) => addBadgeEntry(badge, index));
        }

        function addBadgeEntry(badgeData = {}, index = -1) {
            const badgesContainer = document.getElementById('badges-container');
            const badgeIndex = index === -1 ? badgesContainer.children.length : index;
            const entryDiv = document.createElement('div');
            entryDiv.className = 'badge-entry';
            entryDiv.dataset.index = badgeIndex;
            entryDiv.innerHTML = `
                <h4>Badge ${badgeIndex + 1}</h4>
                ${createFormFields(badgeData, `badge-${badgeIndex}`)}
                <button type="button" class="danger remove-badge-btn">Remove Badge</button>
                <button type="button" class="secondary generate-badge-json-btn">Generate BadgeClass JSON</button>
            `;
            badgesContainer.appendChild(entryDiv);
            entryDiv.querySelector('.remove-badge-btn').addEventListener('click', () => entryDiv.remove());
            entryDiv.querySelector('.generate-badge-json-btn').addEventListener('click', () => generateSingleJson('badge', badgeIndex));
            entryDiv.querySelector(`#badge-${badgeIndex}-image_base_64-upload`).addEventListener('change', (e) => handleImageUpload(e, `badge-${badgeIndex}-image_base_64-preview`, `badge-${badgeIndex}-image_base_64`));
        }

        function createFormFields(data, prefix) {
            const fields = {
                issuer: { id: {r:true, h:"A unique URL pointing to the hosted JSON file for this Issuer Profile."}, name: {r:true}, url: {r:true}, email: {r:false}, image_base_64: {r:false, t:'image'}, publicKey: {r:false, t:'textarea', h:"Optional. A public key in JWK format for signing badges."}, privateKey: {r:false, t:'textarea', p:true, h:"Your secret private key in JWK format. Required for signing."} },
                badge: { alias: {r:true, h:"A short, unique name for this badge used only in this tool's dropdown menus."}, id: {r:true, h:"A unique URL pointing to the hosted JSON file for this BadgeClass."}, name: {r:true}, description: {r:true}, criteria: {r:true, t:'textarea'}, image_base_64: {r:true, t:'image'}, tags: {r:false, h:"Optional. A comma-separated list of keywords."} }
            };
            const fieldType = prefix.startsWith('badge') ? 'badge' : 'issuer';
            
            return Object.entries(fields[fieldType]).map(([key, opts]) => {
                const value = (data && data[key]) ? data[key] : '';
                let inputElement;
                if (opts.t === 'image') {
                    inputElement = `
                        <div class="image-manager">
                            <img id="${prefix}-${key}-preview" src="${value || 'https://via.placeholder.com/100'}" alt="Image preview">
                            <div class="controls">
                                <input type="file" id="${prefix}-${key}-upload" accept="image/png,image/jpeg">
                                <textarea class="form-field hidden" id="${prefix}-${key}">${escapeHtml(value)}</textarea>
                            </div>
                        </div>`;
                } else if (opts.t === 'textarea') {
                    inputElement = `<textarea class="form-field" id="${prefix}-${key}" ${opts.r ? 'required' : ''}>${escapeHtml(value)}</textarea>`;
                } else {
                    inputElement = `<input type="${opts.p ? 'password' : 'text'}" class="form-field" id="${prefix}-${key}" value="${escapeHtml(value)}" ${opts.r ? 'required' : ''}>`;
                }
                
                const visibilityToggle = opts.p ? `<i class="toggle-visibility" id="toggle-pk-visibility">üëÅÔ∏è</i>` : '';
                const inputGroup = opts.p ? `<div class="input-group">${inputElement}${visibilityToggle}</div>` : inputElement;

                const warning = key === 'privateKey' ? `<div class="warning-message"><strong>Warning:</strong> Your private key is a secret. The plain-text export will omit this key.</div>` : '';
                return `<label for="${prefix}-${key}">${key}${opts.r ? ' (required)' : ''}</label>${inputGroup}${opts.h ? `<details><summary>Help</summary><p>${opts.h}</p></details>` : ''}${warning}`;
            }).join('');
        }
        
        function handleImageUpload(event, previewId, textareaId) {
            const file = event.target.files[0];
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById(previewId).src = e.target.result;
                document.getElementById(textareaId).value = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function createKeyGenButton() {
            const btn = document.createElement('button');
            btn.type = 'button'; btn.id = 'generate-key-btn';
            btn.textContent = 'Generate New Key Pair'; btn.className = 'secondary';
            return btn;
        }

        function togglePrivateKeyVisibility() {
            const pkInput = document.getElementById('issuer-privateKey');
            pkInput.type = pkInput.type === 'password' ? 'text' : 'password';
        }

        async function generateKeyPair() {
            try {
                const keyPair = await window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, true, ["sign", "verify"]);
                const publicKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey);
                const privateKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.privateKey);
                document.getElementById('issuer-publicKey').value = JSON.stringify(publicKeyJwk, null, 2);
                document.getElementById('issuer-privateKey').value = JSON.stringify(privateKeyJwk, null, 2);
                alert("New key pair generated and populated in the form.");
            } catch (e) {
                alert(`Key generation failed: ${e.message}`);
            }
        }

        function extractDataFromForm() {
            const newConfig = { issuer: {}, badges: [] };
            document.querySelectorAll('#issuer-fields .form-field').forEach(input => {
                if(input.value) newConfig.issuer[input.id.split('-')[1]] = input.value;
            });
            document.querySelectorAll('#badges-container .badge-entry').forEach(entry => {
                const badge = {};
                entry.querySelectorAll('.form-field').forEach(input => {
                    if(input.value) badge[input.id.split('-')[2]] = input.value;
                });
                newConfig.badges.push(badge);
            });
            return newConfig;
        }
        
        function handleExportPlain() {
            const dataToExport = extractDataFromForm();
            delete dataToExport.issuer.privateKey;
            triggerDownload(new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' }), 'config.json');
        }

        async function handleExportEncrypted() {
            const password = await promptForPassword('Create Encryption Password', true, true);
            if (!password) return;
            const dataToExport = extractDataFromForm();
            const iterations = parseInt(document.getElementById('kdf-iterations').value, 10);
            const encryptedFile = await encryptData(JSON.stringify(dataToExport), password, iterations);
            triggerDownload(new Blob([JSON.stringify(encryptedFile)], { type: 'application/json' }), 'config.encrypted.json');
        }

        function generateSingleJson(type, index) {
            const data = extractDataFromForm();
            let objectToShow = {};
            if (type === 'issuer') {
                const { privateKey, ...issuerData } = data.issuer;
                objectToShow = { "@context": "https://w3id.org/openbadges/v2", type: "Profile", ...issuerData };
                if (objectToShow.publicKey) { try { objectToShow.publicKey = JSON.parse(objectToShow.publicKey); } catch(e){} }
            } else if (type === 'badge' && data.badges[index]) {
                const badge = data.badges[index];
                objectToShow = { "@context": "https://w3id.org/openbadges/v2", type: "BadgeClass", id: badge.id, name: badge.name, description: badge.description, image: badge.image_base_64, criteria: { narrative: badge.criteria }, issuer: data.issuer.id };
                if (badge.tags) objectToShow.tags = badge.tags.split(',').map(t => t.trim());
            }
            alert("Generated JSON:\n\n" + JSON.stringify(objectToShow, null, 2));
        }
        
        function clearSession() {
            if (confirm("Are you sure? This will clear all data and lock the application.")) {
                window.location.reload();
            }
        }

        function promptForPassword(title, needsConfirmation = false, isEncrypting = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('password-modal');
                modal.innerHTML = document.getElementById('password-modal-template').innerHTML;
                const modalTitle = document.getElementById('modal-title');
                const modalWarning = document.getElementById('modal-warning');
                const modalError = document.getElementById('modal-error');
                const modalPassword = document.getElementById('modal-password');
                const modalConfirmPassword = document.getElementById('modal-confirm-password');
                const modalSubmit = document.getElementById('modal-submit');
                const modalCancel = document.getElementById('modal-cancel');

                modalTitle.textContent = title;
                modalConfirmPassword.classList.toggle('hidden', !needsConfirmation);
                if (isEncrypting) {
                    modalWarning.textContent = "Warning: Use a strong, unique password. If you lose it, your encrypted file will be unrecoverable.";
                    modalWarning.classList.remove('hidden');
                }
                modal.classList.remove('hidden');

                modalSubmit.onclick = () => {
                    const pass = modalPassword.value;
                    const confirmPass = modalConfirmPassword.value;
                    if (needsConfirmation && pass !== confirmPass) { displayError(modalError, "Passwords do not match."); return; }
                    if (!pass) { displayError(modalError, "Password cannot be empty."); return; }
                    modal.classList.add('hidden');
                    resolve(pass);
                };
                modalCancel.onclick = () => { modal.classList.add('hidden'); resolve(null); };
            });
        }
        
        async function encryptData(text, password, iterations) {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt, iterations);
            const encryptedContent = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, new TextEncoder().encode(text));
            const now = new Date().toISOString();
            return {
                metadata: { createdAt: now, updatedAt: now, kdf: "PBKDF2", iterations: iterations },
                encryptedData: { iv: Array.from(iv), salt: Array.from(salt), ciphertext: Array.from(new Uint8Array(encryptedContent)) }
            };
        }

        async function decryptData(fileData, password) {
            const { iv, salt, ciphertext } = fileData.encryptedData;
            const iterations = fileData.metadata.iterations;
            const key = await deriveKey(password, new Uint8Array(salt), iterations);
            const decryptedContent = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, key, new Uint8Array(ciphertext));
            return new TextDecoder().decode(decryptedContent);
        }

        async function deriveKey(password, salt, iterations) {
            const keyMaterial = await window.crypto.subtle.importKey('raw', new TextEncoder().encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
            return window.crypto.subtle.deriveKey({ name: 'PBKDF2', salt: salt, iterations: iterations, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
        }
        
        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function attachDynamicListeners() {
            document.getElementById('baker-form').addEventListener('submit', handleBake);
            document.querySelectorAll('input[name="expiration"]').forEach(radio => radio.addEventListener('change', (e) => {
                document.getElementById('expires-date').classList.toggle('hidden', e.target.value === 'no');
            }));
            document.getElementById('verifyFile').addEventListener('change', handleVerifyFile);
            document.getElementById('verify-recipient-btn').addEventListener('click', handleVerifyRecipient);
            document.getElementById('toggle-json-btn').addEventListener('click', () => {
                document.getElementById('verify-output').classList.toggle('hidden');
            });
            document.getElementById('issued-date').valueAsDate = new Date();
        }
        
        async function handleBake(event) {
            event.preventDefault();
            const bakerError = document.getElementById('baker-error');
            const resultSection = document.getElementById('result-section');
            bakerError.classList.add('hidden');
            resultSection.classList.add('hidden');

            const badgeAlias = document.getElementById('badge-select').value;
            const recipientEmail = document.getElementById('recipient-email').value;
            const evidenceUrl = document.getElementById('evidence-url').value;
            const issuedDate = document.getElementById('issued-date').value;
            const expiresOption = document.querySelector('input[name="expiration"]:checked').value;
            const expiresDate = expiresOption === 'yes' ? document.getElementById('expires-date').value : null;
            const verificationType = document.querySelector('input[name="verification"]:checked').value;

            const issuerData = extractDataFromForm().issuer;
            if (verificationType === 'signed' && !issuerData.privateKey) {
                displayError(bakerError, 'A private key must be provided in Issuer Management to create a signed badge.');
                return;
            }

            try {
                const badgeData = config.badges.find(b => b.alias === badgeAlias);
                const assertion = await buildAssertion(badgeData, recipientEmail, issuedDate, expiresDate, evidenceUrl, verificationType);
                const isSigned = verificationType === 'signed';
                const bakedPngDataUri = await bakePng(badgeData.image_base_64, assertion, isSigned);
                
                document.getElementById('json-output').textContent = isSigned ? assertion : JSON.stringify(assertion, null, 2);
                document.getElementById('preview-img').src = bakedPngDataUri;
                const downloadLink = document.getElementById('download-link');
                downloadLink.href = bakedPngDataUri;
                downloadLink.download = `${badgeAlias}-${recipientEmail.split('@')[0]}.png`;
                resultSection.classList.remove('hidden');
            } catch (error) {
                displayError(bakerError, `Could not bake badge: ${error.message}`);
            }
        }

        async function createJws(payload, privateKeyObj) {
            const header = { alg: "ES256", typ: "JWT" };
            const toBase64Url = (data) => btoa(unescape(encodeURIComponent(data))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
            const encodedHeader = toBase64Url(JSON.stringify(header));
            const encodedPayload = toBase64Url(JSON.stringify(payload));
            const dataToSign = new TextEncoder().encode(`${encodedHeader}.${encodedPayload}`);
            const signature = await window.crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } }, privateKeyObj, dataToSign);
            const encodedSignature = toBase64Url(String.fromCharCode(...new Uint8Array(signature)));
            return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
        }
        
        async function buildAssertion(badge, email, issuedOn, expires, evidence, verificationType) {
            const recipientIdentity = await hashRecipient(email);
            const issuerData = extractDataFromForm().issuer;
            
            let badgeClass = {
                type: "BadgeClass", id: badge.id, name: badge.name,
                description: badge.description, image: badge.image_base_64,
                criteria: { narrative: badge.criteria },
                issuer: verificationType === 'signed' ? issuerData.id : { ...issuerData }
            };
            if(badgeClass.issuer.privateKey) delete badgeClass.issuer.privateKey;
            if (badge.tags) badgeClass.tags = badge.tags.split(',').map(t => t.trim());
            Object.keys(badge).forEach(key => {
                if(!['alias','id','name','description','image_base_64','criteria','tags'].includes(key)) {
                    badgeClass[key] = badge[key];
                }
            });


            let assertion = {
                "@context": "https://w3id.org/openbadges/v2",
                type: "Assertion",
                recipient: recipientIdentity,
                badge: badgeClass,
                issuedOn: new Date(`${issuedOn}T00:00:00Z`).toISOString(),
            };
            
            if (expires) assertion.expires = new Date(`${expires}T00:00:00Z`).toISOString();
            if (evidence) assertion.evidence = { id: evidence };
            
            if (verificationType === 'hosted') {
                assertion.id = `urn:uuid:${generateUUID()}`;
                assertion.verification = { type: "hosted" };
                return assertion;
            } else { // signed
                const privateKeyJwk = JSON.parse(issuerData.privateKey);
                const privateKeyForSigning = await window.crypto.subtle.importKey("jwk", privateKeyJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]);
                assertion.verification = { type: "SignedBadge", creator: issuerData.id };
                return createJws(assertion, privateKeyForSigning);
            }
        }

        async function handleVerifyFile(event) {
            const file = event.target.files[0];
            if (!file || file.type !== 'image/png') {
                displayError(document.getElementById('verify-error'), "Invalid file type. Please upload a PNG image.");
                return;
            }

            const verifyError = document.getElementById('verify-error');
            const verifySummary = document.getElementById('verify-summary');
            const verifyOutput = document.getElementById('verify-output');
            verifyError.classList.add('hidden');
            verifySummary.classList.add('hidden');
            verifyOutput.classList.add('hidden');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pngBytes = new Uint8Array(e.target.result);
                    const result = extractBadgeData(pngBytes);
                    if (result && result.assertion) {
                        currentAssertionData = result.assertion;
                        await displayVerificationSummary(result.assertion, result.isSigned, result.jws);
                        verifyOutput.textContent = JSON.stringify(result.assertion, null, 2);
                        verifySummary.classList.remove('hidden');
                    } else {
                        verifyOutput.textContent = 'No valid Open Badge metadata found.';
                        verifyOutput.classList.remove('hidden');
                    }
                } catch (error) {
                    displayError(verifyError, `Error reading badge: ${error.message}`);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        async function displayVerificationSummary(assertion, isSigned, jws) {
            let verificationStatus = { hosted: '‚ö™ Not Checked', signature: '‚ö™ Not Applicable' };
            if (isSigned) {
                verificationStatus.hosted = '‚ö™ Not Applicable';
                verificationStatus.signature = '‚åõ Verifying...';
            }
            
            const renderTable = (status) => {
                let tableHTML = `<table class="summary-table">`;
                const flattened = flattenObject(assertion);
                for(const key in flattened) {
                    let value = flattened[key];
                    if (key.endsWith('issuedOn') || key.endsWith('expires')) {
                        value = new Date(value).toISOString();
                    }
                    tableHTML += `<tr><th>${escapeHtml(key)}</th><td>${escapeHtml(value.toString())}</td></tr>`;
                }

                tableHTML += `
                    <tr><th>Hosted Status</th><td>${status.hosted}</td></tr>
                    <tr><th>Signature Status</th><td>${status.signature}</td></tr>
                </table>`;
                document.getElementById('verify-summary-table').innerHTML = tableHTML;
                document.getElementById('recipient-verification-section').classList.remove('hidden');
            };

            renderTable(verificationStatus);

            if (isSigned) {
                const creatorUrl = assertion.verification?.creator;
                if(creatorUrl) {
                    const verifyResult = await verifyJws(jws, creatorUrl);
                    verificationStatus.signature = verifyResult.success ? '‚úÖ Verified' : `‚ùå Invalid Signature (${verifyResult.reason})`;
                } else {
                    verificationStatus.signature = '‚ö†Ô∏è No public key URL found in badge for verification.';
                }
            } else {
                const issuerUrl = assertion.badge?.issuer?.id;
                if(issuerUrl) {
                    const verifyResult = await verifyUrl(issuerUrl);
                    verificationStatus.hosted = verifyResult.success ? '‚úÖ Verified' : `‚ùå Host Check Failed (${verifyResult.reason})`;
                } else {
                    verificationStatus.hosted = '‚ö†Ô∏è No issuer URL found';
                }
            }
            renderTable(verificationStatus);
        }
        
        function flattenObject(obj, parentKey = '', res = {}) {
            for(let key in obj){
                if(obj.hasOwnProperty(key)){
                    let propName = parentKey ? parentKey + '.' + key : key;
                    if(typeof obj[key] == 'object' && obj[key] !== null && !Array.isArray(obj[key])){
                        flattenObject(obj[key], propName, res);
                    } else {
                        res[propName] = obj[key];
                    }
                }
            }
            return res;
        }

        async function verifyUrl(url) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                return { success: response.ok, reason: response.ok ? 'OK' : `HTTP ${response.status}` };
            } catch (e) { return { success: false, reason: 'Network Error' }; }
        }

        async function verifyJws(jws, publicKeyUrl) {
            try {
                const parts = jws.split('.');
                if (parts.length !== 3) return { success: false, reason: 'Invalid JWS format' };

                const response = await fetch(publicKeyUrl, { mode: 'cors' });
                if (!response.ok) return { success: false, reason: `Could not fetch public key (HTTP ${response.status})` };
                const issuerProfile = await response.json();
                const publicKeyJwk = issuerProfile.publicKey;
                if(!publicKeyJwk) return { success: false, reason: 'Public key not found in issuer profile' };
                
                const publicKey = await window.crypto.subtle.importKey("jwk", publicKeyJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
                
                const dataToVerify = new TextEncoder().encode(`${parts[0]}.${parts[1]}`);
                const signature = new Uint8Array(atob(parts[2].replace(/-/g, '+').replace(/_/g, '/')).split('').map(c => c.charCodeAt(0)));
                
                const isValid = await window.crypto.subtle.verify({ name: "ECDSA", hash: { name: "SHA-256" } }, publicKey, signature, dataToVerify);
                return { success: isValid, reason: isValid ? 'OK' : 'Signature mismatch' };
            } catch (e) {
                console.error("JWS Verification failed:", e);
                return { success: false, reason: e.message };
            }
        }

        async function handleVerifyRecipient() {
            if (!currentAssertionData) return;
            const emailToVerify = document.getElementById('verify-email-input').value;
            const recipientVerificationResult = document.getElementById('recipient-verification-result');
            if (!emailToVerify) {
                recipientVerificationResult.textContent = "Please enter an email to verify.";
                return;
            }
            try {
                const { salt, identity } = currentAssertionData.recipient;
                if (!salt || !identity) throw new Error("Recipient data is incomplete.");
                const expectedHash = identity.split('$')[1] || identity;
                const newHash = (await hashRecipient(emailToVerify, salt)).identity.split('$')[1];
                if (newHash === expectedHash) {
                    recipientVerificationResult.textContent = `‚úÖ Verified for: ${escapeHtml(emailToVerify)}`;
                    recipientVerificationResult.style.color = 'green';
                } else {
                    recipientVerificationResult.textContent = `‚ùå Verification failed for: ${escapeHtml(emailToVerify)}`;
                    recipientVerificationResult.style.color = 'red';
                }
            } catch (e) {
                recipientVerificationResult.textContent = `Could not perform verification: ${e.message}`;
                recipientVerificationResult.style.color = 'red';
            }
        }
        
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        async function hashRecipient(email, salt = `salt-${Date.now()}`) {
            const identityStr = email + salt;
            const data = new TextEncoder().encode(identityStr);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return { type: 'email', hashed: true, salt: salt, identity: `sha256$${hashArray.map(b => b.toString(16).padStart(2, '0')).join('')}` };
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0; return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        
        function extractBadgeData(pngBytes) {
            const decoder = new TextDecoder(); let offset = 8;
            while (offset < pngBytes.length) {
                const view = new DataView(pngBytes.buffer);
                const len = view.getUint32(offset, false);
                const type = decoder.decode(pngBytes.slice(offset + 4, offset + 8));
                if ((type === 'tEXt' || type === 'iTXt') && len > 10) {
                    const chunkData = pngBytes.slice(offset + 8, offset + 8 + len);
                    const nullIndex = chunkData.indexOf(0);
                    if (nullIndex > 0) {
                        const keyword = decoder.decode(chunkData.slice(0, nullIndex));
                        if (keyword === 'openbadges') {
                            let dataOffset = nullIndex + 1;
                            if (type === 'iTXt') { dataOffset += 2; while (chunkData[dataOffset] !== 0) dataOffset++; dataOffset++; while (chunkData[dataOffset] !== 0) dataOffset++; dataOffset++; }
                            const assertionText = decoder.decode(chunkData.slice(dataOffset));
                            const isSigned = assertionText.split('.').length === 3 && assertionText.startsWith('ey');
                            let assertion;
                            if (isSigned) {
                                try { assertion = JSON.parse(atob(assertionText.split('.')[1].replace(/-/g, '+').replace(/_/g, '/'))); }
                                catch (e) { assertion = { error: "Could not decode JWS payload", jws: assertionText }; }
                            } else {
                                assertion = JSON.parse(assertionText);
                            }
                            return { assertion, isSigned, jws: isSigned ? assertionText : null };
                        }
                    }
                }
                if (type === 'IEND') break;
                offset += 12 + len;
            }
            return { assertion: null };
        }

        async function bakePng(base64Png, assertion, isSigned) {
            const pngHeader = "data:image/png;base64,";
            const pngData = atob(base64Png.substring(pngHeader.length));
            const pngBytes = new Uint8Array(pngData.length);
            for (let i = 0; i < pngData.length; i++) pngBytes[i] = pngData.charCodeAt(i);
            
            const keyword = "openbadges"; 
            const text = isSigned ? assertion : JSON.stringify(assertion);
            const encoder = new TextEncoder();
            const keywordBytes = encoder.encode(keyword); const textBytes = encoder.encode(text);
            const chunkData = new Uint8Array(keywordBytes.length + 1 + textBytes.length);
            chunkData.set(keywordBytes, 0); chunkData[keywordBytes.length] = 0;
            chunkData.set(textBytes, keywordBytes.length + 1);
            const chunkType = new Uint8Array([116, 69, 88, 116]);
            const chunkLength = chunkData.length;
            const fullChunk = new Uint8Array(4 + 4 + chunkLength + 4);
            const view = new DataView(fullChunk.buffer);
            view.setUint32(0, chunkLength, false);
            fullChunk.set(chunkType, 4); fullChunk.set(chunkData, 8);
            const crcData = new Uint8Array(4 + chunkLength);
            crcData.set(chunkType, 0); crcData.set(chunkData, 4);
            view.setUint32(8 + chunkLength, crc32(crcData), false);
            
            let iendOffset = -1;
            for (let i = 8; i < pngBytes.length;) {
                const len = (new DataView(pngBytes.buffer)).getUint32(i, false);
                const type = new TextDecoder().decode(pngBytes.slice(i + 4, i + 8));
                if (type === 'IEND') { iendOffset = i; break; }
                i += 12 + len;
            }
            if (iendOffset === -1) throw new Error("Could not find IEND chunk in PNG.");

            const newPngBytes = new Uint8Array(pngBytes.length + fullChunk.length);
            newPngBytes.set(pngBytes.slice(0, iendOffset), 0);
            newPngBytes.set(fullChunk, iendOffset);
            newPngBytes.set(pngBytes.slice(iendOffset), iendOffset + fullChunk.length);
            
            let newPngData = '';
            for (let i = 0; i < newPngBytes.length; i++) newPngData += String.fromCharCode(newPngBytes[i]);
            return pngHeader + btoa(newPngData);
        }

        const crcTable = (() => {
            const table = new Int32Array(256);
            for(let n = 0; n < 256; n++) { let c = n; for(let k = 0; k < 8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1)); table[n] = c; }
            return table;
        })();
        function crc32(bytes) {
            let crc = -1;
            for (let i = 0; i < bytes.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
            return (crc ^ -1) >>> 0;
        }
    });
    </script>
</body>
</html>
