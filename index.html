<!DOCTYPE html>
<!--
Copyright (C) 2025 KSEC - Erez Kalman. All Rights Reserved.

SPDX-License-Identifier: (AGPL-3.0-or-later OR LicenseRef-Erez_Kalman_KSEC-Commercial)

This source code is licensed under a dual-license model.
See the LICENSE, and LICENSE.AGPL.md files for full details.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Badge Management Suite</title>
    <link rel="icon" href="favicon.ico" sizes="32x32">
    <style>
        :root { --primary-color: #007bff; --primary-hover: #0056b3; --border-color: #dee2e6; --danger-color: #dc3545; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f9; color: #333; margin: 0; padding: 20px; }
        main { max-width: 900px; margin: 20px auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        h1, h2, h3, h4 { color: #0056b3; border-bottom: 2px solid #eef; padding-bottom: 10px; }
        h4 { border-bottom: 1px dashed #eef; }
        section { margin-bottom: 30px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; color: #555; }
        input[type="text"], input[type="email"], input[type="date"], input[type="password"], input[type="number"], select, textarea { width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-family: inherit; }
        textarea { min-height: 80px; font-family: "Courier New", Courier, monospace; }
        #json-viewer-modal textarea { height: 300px; }
        button, .download-link { display: inline-block; background-color: var(--primary-color); color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; margin-right: 10px; margin-top: 5px; text-decoration: none; font-family: inherit; }
        button:hover, .download-link:hover { background-color: var(--primary-hover); color: white; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #5a6268; }
        button.danger { background-color: var(--danger-color); }
        button.danger:hover { background-color: #c82333; }
        pre { background-color: #eee; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-family: "Courier New", Courier, monospace; max-height: 300px; overflow-y: auto; }
        .tabs { border-bottom: 2px solid var(--border-color); margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        .tabs .tab-buttons { display: flex; }
        .tabs button { background-color: transparent; border: none; padding: 10px 15px; cursor: pointer; font-size: 18px; color: #0056b3; border-bottom: 3px solid transparent; }
        .tabs button.active { border-bottom: 3px solid var(--primary-color); font-weight: bold; }
        .tabs button:disabled { color: #6c757d; cursor: not-allowed; }
        .error-message { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        .warning-message { color: #856404; background-color: #fff3cd; border: 1px solid #ffeeba; padding: 10px; border-radius: 4px; margin-top: 10px;}
        fieldset { border: 1px solid #ccc; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
        legend { font-weight: bold; color: var(--primary-color); padding: 0 10px; }
        details { margin-bottom: 10px; border: 1px solid #eee; padding: 5px; border-radius: 4px;}
        summary { cursor: pointer; font-weight: normal; color: #555; font-size: 0.9em;}
        .badge-entry { border: 1px dashed #ccc; padding: 15px; margin-bottom: 15px; border-radius: 4px; }
        .modal { position: fixed; z-index: 100; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 30px; border-radius: 8px; width: 90%; max-width: 600px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content.image-viewer { max-width: 90vw; max-height: 90vh; overflow: auto; }
        .modal-content.image-viewer img { max-width: 100%; height: auto; }
        .verification-result { margin-top: 10px; font-weight: bold; }
        .input-group { position: relative; }
        .toggle-visibility { position: absolute; right: 10px; top: 10px; cursor: pointer; user-select: none; font-style: normal; }
        .image-manager { display: flex; align-items: flex-start; gap: 15px; }
        .image-manager img { max-width: 100px; height: auto; border: 1px solid #ddd; }
        .image-manager .controls { flex-grow: 1; }
        .custom-field { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-bottom: 10px; align-items: start; }
        .custom-field-radios { grid-column: 1 / -1; display: flex; justify-content: flex-start; gap: 15px; font-size: 0.8em; margin-top: -10px; margin-bottom: 5px; }
        .custom-field-radios label { font-weight: normal; }
        .custom-field input { margin-bottom: 0; }
        .summary-table { width: 100%; border-collapse: collapse; margin-top: 15px; text-align: left;}
        .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
        .summary-table th { background-color: #f2f2f2; width: 30%; }
        .summary-table img { max-width: 60px; cursor: pointer; transition: transform 0.2s; }
        .summary-table img:hover { transform: scale(1.1); }
        .summary-table h4 { margin: 10px 0 5px; border: none; }
        footer { text-align: center; margin-top: 30px; color: #6c757d; font-size: 0.9em; }
        .hidden { display: none; }
        .dynamic-bake-field { display: flex; align-items: center; gap: 10px; }
        .dynamic-bake-field label { flex-shrink: 0; }
        .dynamic-bake-field input { flex-grow: 1; }
    </style>
</head>
<body>
    <main>
        <h1>Open Badge Management Suite üèÖ</h1>
        
        <div class="tabs">
            <div class="tab-buttons">
                <button id="manager-tab-btn" class="active">Issuer Management</button>
                <button id="baker-tab-btn" disabled title="Load or create a configuration first">Bake a Badge</button>
                <button id="verify-tab-btn">Verify a Badge</button>
            </div>
            <button id="clear-session-btn" class="secondary hidden">Clear & Lock</button>
        </div>

        <div id="manager-view">
            <section id="config-loader-section">
                <h2>Load or Create Configuration</h2>
                <p>Load a plain or encrypted <strong>config.json</strong> file, or create a new configuration from scratch.</p>
                <input type="file" id="configFile" accept=".json">
                <button type="button" id="create-new-config-btn">Create New Config</button>
                <div id="config-error" class="error-message hidden"></div>
            </section>
            <section id="manager-form-section" class="hidden">
                <form id="manager-form">
                    <fieldset>
                        <legend>Issuer Details</legend>
                        <div id="issuer-fields"></div>
                        <div id="issuer-custom-fields" class="custom-fields-container"></div>
                        <button type="button" class="add-custom-field-btn" data-target="issuer-custom-fields" data-prefix="issuer-custom">Add Custom Field</button>
                        <button type="button" id="generate-issuer-json-btn" class="secondary">Generate Issuer JSON</button>
                    </fieldset>
                    <fieldset>
                        <legend>Badge Classes</legend>
                        <div id="badges-container"></div>
                        <button type="button" id="add-badge-btn">Add Another Badge</button>
                    </fieldset>
                    <hr>
                    <fieldset>
                        <legend>Export Options</legend>
                        <label for="kdf-iterations">PBKDF2 Iterations (for encryption):</label>
                        <input type="number" id="kdf-iterations" value="250000" min="10000">
                        <details><summary>Help</summary><p>Higher numbers increase security against brute-force attacks but make encryption/decryption slower. 250,000 is a strong default.</p></details>
                        <button type="button" id="export-plain-btn">Export as Plain JSON</button>
                        <button type="button" id="export-encrypted-btn">Export as Encrypted JSON</button>
                    </fieldset>
                </form>
            </section>
        </div>
        <div id="baker-view" class="hidden"></div>
        <div id="verifier-view" class="hidden"></div>
    </main>

    <div id="password-modal" class="modal hidden"></div>
    <div id="json-viewer-modal" class="modal hidden"></div>
    <div id="image-viewer-modal" class="modal hidden"></div>
    
    <template id="baker-template">
        <section>
            <h2>Issue a Badge</h2>
            <form id="baker-form">
                <div id="baker-error" class="error-message hidden"></div>
                <label for="badge-select">Select Badge:</label>
                <select id="badge-select" required></select>
                
                <div id="dynamic-bake-fields"></div>

                <label for="recipient-email">Recipient Email:</label>
                <input type="email" id="recipient-email" placeholder="jane.doe@example.com" required>
                <label for="evidence-url">Evidence URL (Optional):</label>
                <input type="text" id="evidence-url" placeholder="https://github.com/janedoe/project">
                <label for="issued-date">Issue Date:</label>
                <input type="date" id="issued-date" required>
                <label>Expiration:</label>
                <div><label><input type="radio" name="expiration" value="no" checked> No Expiration</label><label><input type="radio" name="expiration" value="yes"> Set Date</label></div>
                <input type="date" id="expires-date" class="hidden">
                <label>Verification Type:</label>
                <div><label><input type="radio" name="verification" value="hosted" checked> Hosted</label><label><input type="radio" name="verification" value="signed"> Signed</label></div>
                <button type="submit">Bake Badge</button>
            </form>
        </section>
        <section id="result-section" class="hidden">
            <h3>Baked Badge Result</h3>
            <img id="preview-img" style="max-width: 200px; border: 1px solid #ddd; border-radius: 4px;">
            <br>
            <a id="download-link" class="download-link" href="#" download="baked-badge.png">Download Baked Badge</a>
            <pre><code id="json-output"></code></pre>
        </section>
    </template>
    
    <template id="verifier-template">
         <section>
            <h2>Badge Verifier</h2>
            <input type="file" id="verifyFile" accept=".png">
            <div id="verify-error" class="error-message hidden"></div>
            <div id="verify-summary" class="hidden">
                <h3>Badge Summary</h3>
                <div id="verify-summary-table"></div>
                <div id="recipient-verification-section" class="hidden">
                    <h3>Verify Recipient</h3>
                    <input type="email" id="verify-email-input" placeholder="Enter recipient's email to verify identity">
                    <button id="verify-recipient-btn">Verify Recipient</button>
                    <div id="recipient-verification-result" class="verification-result"></div>
                </div>
                <button id="toggle-json-btn" style="margin-top: 15px;">Show/Hide Full Assertion</button>
            </div>
            <pre id="verify-output" class="hidden"></pre>
        </section>
    </template>

    <template id="password-modal-template">
        <div class="modal-content">
            <h3 id="modal-title">Enter Password</h3>
            <div id="modal-warning" class="warning-message hidden"></div>
            <div id="modal-error" class="error-message hidden"></div>
            <input type="password" id="modal-password" placeholder="Password">
            <input type="password" id="modal-confirm-password" placeholder="Confirm Password" class="hidden">
            <button id="modal-submit">Submit</button>
            <button id="modal-cancel" class="secondary">Cancel</button>
        </div>
    </template>

    <template id="json-viewer-modal-template">
        <div class="modal-content">
            <h3 id="json-viewer-title">Generated JSON</h3>
            <textarea id="json-viewer-content" readonly></textarea>
            <br>
            <button id="json-download-btn">Download</button>
            <button id="json-close-btn" class="secondary">Close</button>
        </div>
    </template>

    <template id="image-viewer-modal-template">
        <div class="modal-content image-viewer">
            <img id="image-viewer-img" src="">
            <br>
            <a id="image-download-link" class="download-link" href="#">Download Image</a>
            <button id="image-close-btn" class="secondary">Close</button>
        </div>
    </template>
    
    <footer>(C) 2025 KSEC - Erez Kalman</footer>

    <script>
    window.addEventListener('DOMContentLoaded', () => {
        let config = null;
        let currentAssertionData = null;

        const tabs = {
            manager: { btn: document.getElementById('manager-tab-btn'), view: document.getElementById('manager-view') },
            baker:   { btn: document.getElementById('baker-tab-btn'),   view: document.getElementById('baker-view') },
            verify:  { btn: document.getElementById('verify-tab-btn'), view: document.getElementById('verifier-view') }
        };
        const configFile = document.getElementById('configFile');
        const configLoaderSection = document.getElementById('config-loader-section');
        const managerFormSection = document.getElementById('manager-form-section');
        const createNewConfigBtn = document.getElementById('create-new-config-btn');
        const clearSessionBtn = document.getElementById('clear-session-btn');
        const passwordModal = document.getElementById('password-modal');
        const configError = document.getElementById('config-error');

        initializeViewsAndListeners();

        document.querySelector('.tabs .tab-buttons').addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const tabName = event.target.id.split('-')[0];
                switchTab(tabName);
            }
        });

        configFile.addEventListener('change', handleConfigFile);
        createNewConfigBtn.addEventListener('click', createNewConfig);
        clearSessionBtn.addEventListener('click', clearSession);
        
        function initializeViewsAndListeners() {
            tabs.baker.view.innerHTML = document.getElementById('baker-template').innerHTML;
            tabs.verify.view.innerHTML = document.getElementById('verifier-template').innerHTML;
            passwordModal.innerHTML = document.getElementById('password-modal-template').innerHTML;
            attachDynamicListeners();
            document.getElementById('add-badge-btn').addEventListener('click', () => addBadgeEntry());
            document.getElementById('export-plain-btn').addEventListener('click', handleExportPlain);
            document.getElementById('export-encrypted-btn').addEventListener('click', handleExportEncrypted);
            document.getElementById('generate-issuer-json-btn').addEventListener('click', () => generateSingleJson('issuer'));
            document.querySelectorAll('.add-custom-field-btn').forEach(btn => {
                btn.addEventListener('click', (e) => addCustomFieldInput(e.target.dataset.target, e.target.dataset.prefix));
            });
        }
        
        function switchTab(tabName) {
            if (!tabs[tabName] || tabs[tabName].btn.disabled) return;
            Object.values(tabs).forEach(tab => {
                tab.view.classList.add('hidden');
                tab.btn.classList.remove('active');
            });
            tabs[tabName].view.classList.remove('hidden');
            tabs[tabName].btn.classList.add('active');
        }
        
        function displayError(element, message) {
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function createNewConfig() {
            const defaultConfig = {
                issuer: { id: "", name: "", url: "", email: "", description: "" },
                badges: [{ alias: "", id: "", name: "", description: "", criteria: "", image_base_64: "", tags: "" }]
            };
            processConfig(JSON.stringify(defaultConfig));
        }

        async function handleConfigFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                displayError(configError, "Invalid file type. Please upload a JSON file.");
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => await processUploadedConfig(e.target.result);
            reader.readAsText(file);
        }

        async function processUploadedConfig(content) {
            try {
                const parsedJson = JSON.parse(content);
                if (parsedJson.metadata && parsedJson.encryptedData) {
                    const password = await promptForPassword('Decrypt Configuration');
                    if (!password) return;
                    let decryptedText;
                    try {
                        decryptedText = await decryptData(parsedJson, password);
                    } catch (e) {
                        throw new Error("Decryption failed. Please check your password or the file may be corrupt.");
                    }
                    processConfig(decryptedText);
                } else {
                    processConfig(content);
                }
            } catch (err) {
                displayError(configError, `Error processing file: ${err.message}`);
            }
        }

        function processConfig(configText) {
            configError.classList.add('hidden');
            try {
                config = JSON.parse(configText);
                if (!config.issuer || !config.badges) throw new Error("Config must contain 'issuer' and 'badges' keys.");
                
                populateManagerForm(config);
                populateBadgeSelector(config.badges);

                configLoaderSection.classList.add('hidden');
                managerFormSection.classList.remove('hidden');
                tabs.baker.btn.disabled = false;
                tabs.baker.btn.title = "Bake a Badge";
                clearSessionBtn.classList.remove('hidden');
                switchTab('manager');
            } catch (error) {
                displayError(configError, `Error processing config file: ${error.message}`);
            }
        }

        function populateManagerForm(data) {
            const definedIssuerKeys = ['id', 'name', 'url', 'email', 'description', 'image_base_64', 'publicKey', 'privateKey'];
            const standardIssuerFields = {};
            const customIssuerFields = (data.issuer.customFields || {});
            for (const key in data.issuer) {
                if (definedIssuerKeys.includes(key)) standardIssuerFields[key] = data.issuer[key];
            }
            
            document.getElementById('issuer-fields').innerHTML = createFormFields(standardIssuerFields, 'issuer');
            const issuerCustomContainer = document.getElementById('issuer-custom-fields');
            issuerCustomContainer.innerHTML = '';
            for (const key in customIssuerFields) {
                addCustomFieldInput('issuer-custom-fields', 'issuer-custom', key, customIssuerFields[key].value, customIssuerFields[key].type);
            }
            
            const genKeyBtn = document.getElementById('generate-key-btn');
            if (genKeyBtn) genKeyBtn.addEventListener('click', generateKeyPair);
            
            const togglePkBtn = document.getElementById('toggle-pk-visibility');
            if (togglePkBtn) togglePkBtn.addEventListener('click', togglePrivateKeyVisibility);

            const issuerImgUpload = document.getElementById('issuer-image_base_64-upload');
            if (issuerImgUpload) issuerImgUpload.addEventListener('change', (e) => handleImageUpload(e, 'issuer-image_base_64-preview', 'issuer-image_base_64'));
            
            const badgesContainer = document.getElementById('badges-container');
            badgesContainer.innerHTML = '';
            data.badges.forEach((badge, index) => addBadgeEntry(badge, index));
        }

        function addBadgeEntry(badgeData = {}, index = -1) {
            const badgesContainer = document.getElementById('badges-container');
            const badgeIndex = index === -1 ? badgesContainer.children.length : index;
            
            const definedBadgeKeys = ['alias', 'id', 'name', 'description', 'criteria', 'image_base_64', 'tags'];
            const standardBadgeFields = {};
            const customBadgeFields = (badgeData.customFields || {});
            for (const key in badgeData) {
                if (definedBadgeKeys.includes(key)) standardBadgeFields[key] = badgeData[key];
            }

            const entryDiv = document.createElement('div');
            entryDiv.className = 'badge-entry';
            entryDiv.dataset.index = badgeIndex;
            entryDiv.innerHTML = `
                <h4>Badge ${badgeIndex + 1}</h4>
                <div class="standard-fields">${createFormFields(standardBadgeFields, `badge-${badgeIndex}`)}</div>
                <div id="badge-${badgeIndex}-custom-fields" class="custom-fields-container"></div>
                <button type="button" class="add-custom-field-btn" data-target="badge-${badgeIndex}-custom-fields" data-prefix="badge-${badgeIndex}-custom">Add Custom Field</button>
                <button type="button" class="danger remove-badge-btn">Remove Badge</button>
                <button type="button" class="secondary generate-badge-json-btn">Generate BadgeClass JSON</button>
            `;
            badgesContainer.appendChild(entryDiv);
            
            const badgeCustomContainer = entryDiv.querySelector(`#badge-${badgeIndex}-custom-fields`);
            for (const key in customBadgeFields) {
                addCustomFieldInput(`badge-${badgeIndex}-custom-fields`, `badge-${badgeIndex}-custom`, key, customBadgeFields[key].value, customBadgeFields[key].type);
            }
            
            entryDiv.querySelector('.add-custom-field-btn').addEventListener('click', (e) => addCustomFieldInput(e.target.dataset.target, e.target.dataset.prefix));
            entryDiv.querySelector('.remove-badge-btn').addEventListener('click', () => entryDiv.remove());
            entryDiv.querySelector('.generate-badge-json-btn').addEventListener('click', () => generateSingleJson('badge', badgeIndex));
            const badgeImgUpload = entryDiv.querySelector(`#badge-${badgeIndex}-image_base_64-upload`);
            if (badgeImgUpload) badgeImgUpload.addEventListener('change', (e) => handleImageUpload(e, `badge-${badgeIndex}-image_base_64-preview`, `badge-${badgeIndex}-image_base_64`));
        }

        function addCustomFieldInput(targetId, prefix, key = '', value = '', type = 'global') {
            const container = document.getElementById(targetId);
            const fieldIndex = Date.now(); // Use timestamp for a more unique ID
            const div = document.createElement('div');
            div.className = 'custom-field';

            const radioName = `${prefix}-radios-${fieldIndex}`;
            div.innerHTML = `
                <div>
                    <input type="text" class="form-field" data-custom-key="true" placeholder="Field Name (e.g., version)" value="${escapeHtml(key)}">
                    <input type="text" class="form-field" data-custom-value="true" placeholder="Field Value" value="${escapeHtml(value)}">
                </div>
                <div class="custom-field-radios">
                    <label><input type="radio" name="${radioName}" value="global" ${type === 'global' ? 'checked' : ''}> Global</label>
                    <label><input type="radio" name="${radioName}" value="baking-optional" ${type === 'baking-optional' ? 'checked' : ''}> Baking - Optional</label>
                    <label><input type="radio" name="${radioName}" value="baking-required" ${type === 'baking-required' ? 'checked' : ''}> Baking - Required</label>
                </div>
                <button type="button" class="danger">X</button>
            `;
            container.appendChild(div);
            div.querySelector('.danger').addEventListener('click', () => div.remove());
        }

        function createFormFields(data, prefix) {
            const fields = {
                issuer: { id: {r:true}, name: {r:true}, url: {r:true}, email: {r:false}, description: {r:false, t:'textarea'}, image_base_64: {r:false, t:'image'}, publicKey: {r:false, t:'textarea', h:"Optional. JWK for signing."}, privateKey: {r:false, t:'textarea', p:true, h:"Secret JWK for signing."} },
                badge: { alias: {r:true}, id: {r:true}, name: {r:true}, description: {r:true}, criteria: {r:true, t:'textarea'}, image_base_64: {r:true, t:'image'}, tags: {r:false, h:"Comma-separated"} }
            };
            const fieldType = prefix.startsWith('badge') ? 'badge' : 'issuer';
            
            let html = Object.entries(fields[fieldType]).map(([key, opts]) => {
                const value = (data && data[key]) ? data[key] : '';
                const title = opts.h || `A comma-separated list of keywords.`;
                let inputElement;
                if (opts.t === 'image') {
                    const placeholder = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    inputElement = `
                        <div class="image-manager">
                            <img id="${prefix}-${key}-preview" src="${value || placeholder}" alt="Image preview">
                            <div class="controls">
                                <input type="file" id="${prefix}-${key}-upload" accept="image/png,image/jpeg">
                                <textarea class="form-field hidden" id="${prefix}-${key}">${escapeHtml(value)}</textarea>
                            </div>
                        </div>`;
                } else if (opts.t === 'textarea') {
                    inputElement = `<textarea class="form-field" id="${prefix}-${key}" ${opts.r ? 'required' : ''} placeholder="${opts.h || ''}">${escapeHtml(value)}</textarea>`;
                } else {
                    inputElement = `<input type="${opts.p ? 'password' : 'text'}" class="form-field" id="${prefix}-${key}" value="${escapeHtml(value)}" ${opts.r ? 'required' : ''} placeholder="${opts.h || ''}">`;
                }
                
                const visibilityToggle = opts.p ? `<i class="toggle-visibility" id="toggle-pk-visibility">üëÅÔ∏è</i>` : '';
                const inputGroup = opts.p ? `<div class="input-group">${inputElement}${visibilityToggle}</div>` : inputElement;
                const warning = key === 'privateKey' ? `<div class="warning-message"><strong>Warning:</strong> Your private key is a secret. The plain-text export will omit this key.</div>` : '';
                return `<label for="${prefix}-${key}">${key.replace(/_/g, ' ')}${opts.r ? ' *' : ''}</label>${inputGroup}${warning}`;
            }).join('');

            if (fieldType === 'issuer') {
                html += `<button type="button" id="generate-key-btn" class="secondary">Generate New Key Pair</button>`;
            }
            return html;
        }
        
        function handleImageUpload(event, previewId, textareaId) {
            const file = event.target.files[0];
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById(previewId).src = e.target.result;
                document.getElementById(textareaId).value = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function togglePrivateKeyVisibility() {
            const pkInput = document.getElementById('issuer-privateKey');
            pkInput.type = pkInput.type === 'password' ? 'text' : 'password';
        }

        async function generateKeyPair() {
            try {
                const keyPair = await window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, true, ["sign", "verify"]);
                const publicKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey);
                const privateKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.privateKey);
                document.getElementById('issuer-publicKey').value = JSON.stringify(publicKeyJwk, null, 2);
                document.getElementById('issuer-privateKey').value = JSON.stringify(privateKeyJwk, null, 2);
                alert("New key pair generated and populated in the form.");
            } catch (e) {
                alert(`Key generation failed: ${e.message}`);
            }
        }

        function extractDataFromForm() {
            const newConfig = { issuer: { customFields: {} }, badges: [] };
            
            document.querySelectorAll('#issuer-fields .form-field').forEach(input => {
                const key = input.id.split('-')[1];
                if(input.value) newConfig.issuer[key] = input.value;
            });
            document.querySelectorAll('#issuer-custom-fields .custom-field').forEach(div => {
                const keyInput = div.querySelector('[data-custom-key]');
                const valueInput = div.querySelector('[data-custom-value]');
                const typeInput = div.querySelector('input[type="radio"]:checked');
                if (keyInput && valueInput && typeInput && keyInput.value) {
                    newConfig.issuer.customFields[keyInput.value] = {
                        type: typeInput.value,
                        value: valueInput.value
                    };
                }
            });

            document.querySelectorAll('#badges-container .badge-entry').forEach(entry => {
                const badge = { customFields: {} };
                const index = entry.dataset.index;
                
                entry.querySelectorAll('.standard-fields .form-field').forEach(input => {
                    const key = input.id.split('-')[2];
                    if(input.value) badge[key] = input.value;
                });
                
                entry.querySelectorAll(`#badge-${index}-custom-fields .custom-field`).forEach(div => {
                    const keyInput = div.querySelector('[data-custom-key]');
                    const valueInput = div.querySelector('[data-custom-value]');
                    const typeInput = div.querySelector('input[type="radio"]:checked');
                    if (keyInput && valueInput && typeInput && keyInput.value) {
                        badge.customFields[keyInput.value] = {
                            type: typeInput.value,
                            value: valueInput.value
                        };
                    }
                });
                newConfig.badges.push(badge);
            });
            return newConfig;
        }
        
        function handleExportPlain() {
            const dataToExport = extractDataFromForm();
            delete dataToExport.issuer.privateKey;
            triggerDownload(new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' }), 'config.json');
        }

        async function handleExportEncrypted() {
            const password = await promptForPassword('Create Encryption Password', true, true);
            if (!password) return;
            const dataToExport = extractDataFromForm();
            const iterations = parseInt(document.getElementById('kdf-iterations').value, 10);
            const encryptedFile = await encryptData(JSON.stringify(dataToExport), password, iterations);
            triggerDownload(new Blob([JSON.stringify(encryptedFile)], { type: 'application/json' }), 'config.encrypted.json');
        }

        function generateSingleJson(type, index) {
            const data = extractDataFromForm();
            let objectToShow = {};
            let filename = 'data.json';
            if (type === 'issuer') {
                const { privateKey, customFields, ...issuerData } = data.issuer;
                objectToShow = { "@context": "https://w3id.org/openbadges/v2", type: "Profile", ...issuerData };
                if (customFields) {
                    for(const key in customFields) {
                        if (customFields[key].type === 'global') objectToShow[key] = customFields[key].value;
                    }
                }
                if (objectToShow.publicKey) { try { objectToShow.publicKey = JSON.parse(objectToShow.publicKey); } catch(e){} }
                filename = 'issuer.json';
            } else if (type === 'badge' && data.badges[index]) {
                const { alias, customFields, ...badge } = data.badges[index];
                objectToShow = { "@context": "https://w3id.org/openbadges/v2", type: "BadgeClass", ...badge, criteria: { narrative: badge.criteria }, issuer: data.issuer.id };
                delete objectToShow.image_base_64;
                objectToShow.image = badge.image_base_64;
                if (badge.tags) objectToShow.tags = badge.tags.split(',').map(t => t.trim());
                if (customFields) {
                    for(const key in customFields) {
                        if (customFields[key].type === 'global') objectToShow[key] = customFields[key].value;
                    }
                }
                filename = `badgeclass-${alias || 'badge'}.json`;
            }
            
            const modal = document.getElementById('json-viewer-modal');
            modal.innerHTML = document.getElementById('json-viewer-modal-template').innerHTML;
            const contentTextarea = document.getElementById('json-viewer-content');
            const downloadBtn = document.getElementById('json-download-btn');
            const closeBtn = document.getElementById('json-close-btn');
            const jsonString = JSON.stringify(objectToShow, null, 2);
            contentTextarea.value = jsonString;
            downloadBtn.onclick = () => triggerDownload(new Blob([jsonString], { type: 'application/json' }), filename);
            closeBtn.onclick = () => modal.classList.add('hidden');
            modal.classList.remove('hidden');
        }
        
        function clearSession() {
            if (confirm("Are you sure? This will clear all data and lock the application.")) {
                window.location.reload();
            }
        }

        function promptForPassword(title, needsConfirmation = false, isEncrypting = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('password-modal');
                const modalTitle = modal.querySelector('#modal-title');
                const modalWarning = modal.querySelector('#modal-warning');
                const modalError = modal.querySelector('#modal-error');
                const modalPassword = modal.querySelector('#modal-password');
                const modalConfirmPassword = modal.querySelector('#modal-confirm-password');
                const modalSubmit = modal.querySelector('#modal-submit');
                const modalCancel = modal.querySelector('#modal-cancel');
                
                modalTitle.textContent = title;
                modalPassword.value = '';
                modalConfirmPassword.value = '';
                modalError.classList.add('hidden');
                modalConfirmPassword.classList.toggle('hidden', !needsConfirmation);
                modalWarning.classList.toggle('hidden', !isEncrypting);
                if (isEncrypting) {
                    modalWarning.textContent = "Warning: Use a strong, unique password. If you lose it, your encrypted file will be unrecoverable.";
                }
                modal.classList.remove('hidden');

                const submitHandler = () => {
                    const pass = modalPassword.value;
                    const confirmPass = modalConfirmPassword.value;
                    if (needsConfirmation && pass !== confirmPass) { displayError(modalError, "Passwords do not match."); return; }
                    if (!pass) { displayError(modalError, "Password cannot be empty."); return; }
                    cleanup();
                    resolve(pass);
                };
                const cancelHandler = () => { cleanup(); resolve(null); };
                const cleanup = () => {
                    modal.classList.add('hidden');
                    modalSubmit.removeEventListener('click', submitHandler);
                    modalCancel.removeEventListener('click', cancelHandler);
                };
                modalSubmit.addEventListener('click', submitHandler);
                modalCancel.addEventListener('click', cancelHandler);
            });
        }
        
        async function encryptData(text, password, iterations) {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt, iterations);
            const encryptedContent = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, new TextEncoder().encode(text));
            const now = new Date().toISOString();
            return {
                metadata: { createdAt: now, updatedAt: now, kdf: "PBKDF2", iterations: iterations },
                encryptedData: { iv: Array.from(iv), salt: Array.from(salt), ciphertext: Array.from(new Uint8Array(encryptedContent)) }
            };
        }

        async function decryptData(fileData, password) {
            const { iv, salt, ciphertext } = fileData.encryptedData;
            const iterations = fileData.metadata.iterations;
            const key = await deriveKey(password, new Uint8Array(salt), iterations);
            const decryptedContent = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, key, new Uint8Array(ciphertext));
            return new TextDecoder().decode(decryptedContent);
        }

        async function deriveKey(password, salt, iterations) {
            const keyMaterial = await window.crypto.subtle.importKey('raw', new TextEncoder().encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
            return window.crypto.subtle.deriveKey({ name: 'PBKDF2', salt: salt, iterations: iterations, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
        }
        
        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function populateBadgeSelector(badges) {
            const badgeSelect = document.getElementById('badge-select');
            if (!badgeSelect) return;
            badgeSelect.innerHTML = '<option value="" disabled selected>-- Select a Badge --</option>';
            badges.forEach(badge => {
                const option = document.createElement('option');
                option.value = badge.alias;
                option.textContent = `${badge.name} (${badge.alias})`;
                badgeSelect.appendChild(option);
            });
        }
        
        function updateBakeForm() {
            const badgeSelect = document.getElementById('badge-select');
            const dynamicFieldsContainer = document.getElementById('dynamic-bake-fields');
            dynamicFieldsContainer.innerHTML = '';
            
            const selectedAlias = badgeSelect.value;
            if (!selectedAlias || !config) return;

            const badge = config.badges.find(b => b.alias === selectedAlias);
            if (badge && badge.customFields) {
                for (const key in badge.customFields) {
                    const field = badge.customFields[key];
                    if (field.type.startsWith('baking-')) {
                        const div = document.createElement('div');
                        div.className = 'dynamic-bake-field';
                        const isRequired = field.type === 'baking-required';
                        
                        let inputHTML = `<input type="text" id="bake-custom-${key}" data-key="${key}" ${isRequired ? 'required' : ''}>`;
                        if (!isRequired) {
                            inputHTML += `<button type="button" class="danger">X</button>`;
                        }
                        
                        div.innerHTML = `
                            <label for="bake-custom-${key}">${key}${isRequired ? ' *' : ''}</label>
                            ${inputHTML}
                        `;
                        dynamicFieldsContainer.appendChild(div);

                        if (!isRequired) {
                            div.querySelector('.danger').addEventListener('click', () => div.remove());
                        }
                    }
                }
            }
        }

        function attachDynamicListeners() {
            document.getElementById('baker-form').addEventListener('submit', handleBake);
            document.getElementById('badge-select').addEventListener('change', updateBakeForm);
            document.querySelectorAll('input[name="expiration"]').forEach(radio => radio.addEventListener('change', (e) => {
                document.getElementById('expires-date').classList.toggle('hidden', e.target.value === 'no');
            }));
            document.getElementById('verifyFile').addEventListener('change', handleVerifyFile);
            document.getElementById('verify-recipient-btn').addEventListener('click', handleVerifyRecipient);
            document.getElementById('toggle-json-btn').addEventListener('click', () => {
                document.getElementById('verify-output').classList.toggle('hidden');
            });
            document.getElementById('issued-date').valueAsDate = new Date();
        }
        
        async function handleBake(event) {
            event.preventDefault();
            const bakerError = document.getElementById('baker-error');
            const resultSection = document.getElementById('result-section');
            bakerError.classList.add('hidden');
            resultSection.classList.add('hidden');

            const badgeAlias = document.getElementById('badge-select').value;
            const recipientEmail = document.getElementById('recipient-email').value;
            const evidenceUrl = document.getElementById('evidence-url').value;
            const issuedDate = document.getElementById('issued-date').value;
            const expiresOption = document.querySelector('input[name="expiration"]:checked').value;
            const expiresDate = expiresOption === 'yes' ? document.getElementById('expires-date').value : null;
            const verificationType = document.querySelector('input[name="verification"]:checked').value;

            if (!badgeAlias) {
                displayError(bakerError, 'You must select a badge to bake.');
                return;
            }

            const bakeTimeCustomFields = {};
            document.querySelectorAll('#dynamic-bake-fields .dynamic-bake-field').forEach(field => {
                const input = field.querySelector('input[type="text"]');
                if (input.value) { // Only include if value is not empty
                    bakeTimeCustomFields[input.dataset.key] = input.value;
                }
            });

            const issuerData = extractDataFromForm().issuer;
            if (verificationType === 'signed' && !issuerData.privateKey) {
                displayError(bakerError, 'A private key must be provided in Issuer Management to create a signed badge.');
                return;
            }

            try {
                const badgeData = config.badges.find(b => b.alias === badgeAlias);
                const assertion = await buildAssertion(badgeData, recipientEmail, issuedDate, expiresDate, evidenceUrl, verificationType, bakeTimeCustomFields);
                const isSigned = verificationType === 'signed';
                const bakedPngDataUri = await bakePng(badgeData.image_base_64, assertion, isSigned);
                
                document.getElementById('json-output').textContent = isSigned ? assertion : JSON.stringify(assertion, null, 2);
                document.getElementById('preview-img').src = bakedPngDataUri;
                const downloadLink = document.getElementById('download-link');
                downloadLink.href = bakedPngDataUri;
                downloadLink.download = `${badgeAlias}-${recipientEmail.split('@')[0]}.png`;
                resultSection.classList.remove('hidden');
            } catch (error) {
                displayError(bakerError, `Could not bake badge: ${error.message}`);
            }
        }

        async function createJws(payload, privateKeyObj) {
            const header = { alg: "ES256", typ: "JWT" };
            const toBase64Url = (data) => btoa(unescape(encodeURIComponent(data))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
            const encodedHeader = toBase64Url(JSON.stringify(header));
            const encodedPayload = toBase64Url(JSON.stringify(payload));
            const dataToSign = new TextEncoder().encode(`${encodedHeader}.${encodedPayload}`);
            const signature = await window.crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } }, privateKeyObj, dataToSign);
            const encodedSignature = toBase64Url(String.fromCharCode(...new Uint8Array(signature)));
            return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
        }
        
        async function buildAssertion(badge, email, issuedOn, expires, evidence, verificationType, bakeTimeCustomFields) {
            const recipientIdentity = await hashRecipient(email);
            const issuerData = extractDataFromForm().issuer;
            
            let badgeClass = {
                type: "BadgeClass", id: badge.id, name: badge.name,
                description: badge.description, image: badge.image_base_64,
                criteria: { narrative: badge.criteria },
                issuer: verificationType === 'signed' ? issuerData.id : { ...issuerData }
            };
            if(badgeClass.issuer.privateKey) delete badgeClass.issuer.privateKey;
            if(badgeClass.issuer.customFields) delete badgeClass.issuer.customFields;
            if (badge.tags) badgeClass.tags = badge.tags.split(',').map(t => t.trim());
            
            if (issuerData.customFields) {
                for (const key in issuerData.customFields) {
                    if (issuerData.customFields[key].type === 'global') badgeClass.issuer[key] = issuerData.customFields[key].value;
                }
            }
            if (badge.customFields) {
                for (const key in badge.customFields) {
                    if (badge.customFields[key].type === 'global') badgeClass[key] = badge.customFields[key].value;
                }
            }

            let assertion = {
                "@context": "https://w3id.org/openbadges/v2",
                type: "Assertion",
                recipient: recipientIdentity,
                badge: badgeClass,
                issuedOn: new Date(`${issuedOn}T00:00:00Z`).toISOString(),
                ...bakeTimeCustomFields
            };
            
            if (expires) assertion.expires = new Date(`${expires}T00:00:00Z`).toISOString();
            if (evidence) assertion.evidence = { id: evidence };
            
            if (verificationType === 'hosted') {
                assertion.id = `urn:uuid:${generateUUID()}`;
                assertion.verification = { type: "hosted" };
                return assertion;
            } else { // signed
                const privateKeyJwk = JSON.parse(issuerData.privateKey);
                const privateKeyForSigning = await window.crypto.subtle.importKey("jwk", privateKeyJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]);
                assertion.verification = { type: "SignedBadge", creator: issuerData.id };
                return createJws(assertion, privateKeyForSigning);
            }
        }

        async function handleVerifyFile(event) {
            const file = event.target.files[0];
            if (!file || file.type !== 'image/png') {
                displayError(document.getElementById('verify-error'), "Invalid file type. Please upload a PNG image.");
                return;
            }
            const verifyError = document.getElementById('verify-error');
            const verifySummary = document.getElementById('verify-summary');
            const verifyOutput = document.getElementById('verify-output');
            verifyError.classList.add('hidden');
            verifySummary.classList.add('hidden');
            verifyOutput.classList.add('hidden');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pngBytes = new Uint8Array(e.target.result);
                    const result = extractBadgeData(pngBytes);
                    if (result && result.assertion) {
                        currentAssertionData = result.assertion;
                        await displayVerificationSummary(result.assertion, result.isSigned, result.jws);
                        verifyOutput.textContent = JSON.stringify(result.assertion, null, 2);
                        verifySummary.classList.remove('hidden');
                    } else {
                        verifyOutput.textContent = 'No valid Open Badge metadata found.';
                        verifyOutput.classList.remove('hidden');
                    }
                } catch (error) {
                    displayError(verifyError, `Error reading badge: ${error.message}`);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        async function displayVerificationSummary(assertion, isSigned, jws) {
            const fieldMap = {
                badge: { label: 'Badge Details', fields: { 'name': 'Name', 'description': 'Description', 'image_base_64': 'Image', 'criteria.narrative': 'Criteria' } },
                issuer: { label: 'Issuer Details', fields: { 'name': 'Name', 'url': 'URL', 'id': 'Profile URL', 'image_base_64': 'Logo' } },
                recipient: { label: 'Recipient', fields: { 'identity': 'Identity', 'hashed': 'Hashed', 'salt': 'Salt', 'type': 'Type' } },
                assertion: { label: 'Assertion Details', fields: { 'issuedOn': 'Issued On', 'expires': 'Expires', 'id': 'ID', 'evidence.id': 'Evidence' } }
            };

            let tableHTML = `<table class="summary-table">`;
            for (const section in fieldMap) {
                const sourceObject = section === 'assertion' ? assertion : getNested(assertion, section);
                if (!sourceObject) continue;
                
                tableHTML += `<tr><th colspan="2"><h4>${fieldMap[section].label}</h4></th></tr>`;
                for(const key in fieldMap[section].fields) {
                    const value = getNested(sourceObject, key);
                    if (value !== undefined && value !== null) {
                        const label = fieldMap[section].fields[key];
                        let renderedValue = escapeHtml(value.toString());
                        if ((key.endsWith('image') || key.endsWith('image_base_64')) && value.startsWith('data:image')) {
                            renderedValue = `<img src="${value}" alt="${label} preview" class="summary-image">`;
                        } else if (key.endsWith('On') || key === 'expires') {
                           try { renderedValue = new Date(value).toUTCString(); } catch(e){}
                        } else if (key === 'identity') {
                            renderedValue = `<span title="${value}">${value.substring(0, 50)}...</span>`;
                        }
                        tableHTML += `<tr><th>${label}</th><td>${renderedValue}</td></tr>`;
                    }
                }
            }
            
            let verificationStatus = { hosted: '‚ö™ Not Checked', signature: '‚ö™ Not Applicable' };
            if (isSigned) {
                verificationStatus.hosted = '‚ö™ Not Applicable';
                verificationStatus.signature = '‚åõ Verifying...';
            }
            
            tableHTML += `<tr><th colspan="2"><h4>Verification Status</h4></th></tr>`;
            tableHTML += `<tr><th>Hosted Status</th><td id="status-hosted">${verificationStatus.hosted}</td></tr>`;
            tableHTML += `<tr><th>Signature Status</th><td id="status-signature">${verificationStatus.signature}</td></tr>`;
            tableHTML += `</table>`;
            
            const summaryTableDiv = document.getElementById('verify-summary-table');
            summaryTableDiv.innerHTML = tableHTML;

            summaryTableDiv.querySelectorAll('.summary-image').forEach(img => {
                img.addEventListener('click', (e) => showImageModal(e.target.src));
            });

            document.getElementById('recipient-verification-section').classList.remove('hidden');

            if (isSigned) {
                const creatorUrl = getNested(assertion, 'verification.creator');
                if(creatorUrl) {
                    const verifyResult = await verifyJws(jws, creatorUrl);
                    document.getElementById('status-signature').textContent = verifyResult.success ? '‚úÖ Verified' : `‚ùå Invalid Signature (${verifyResult.reason})`;
                } else {
                    document.getElementById('status-signature').textContent = '‚ö†Ô∏è No public key URL found in badge for verification.';
                }
            } else {
                let issuerId = '';
                const issuer = getNested(assertion, 'badge.issuer');
                if (typeof issuer === 'string') {
                    issuerId = issuer;
                } else if (typeof issuer === 'object' && issuer !== null) {
                    issuerId = issuer.id;
                }
                
                if(issuerId) {
                    const verifyResult = await verifyUrl(issuerId);
                    document.getElementById('status-hosted').textContent = verifyResult.success ? '‚úÖ Verified' : `‚ùå Host Check Failed (${verifyResult.reason})`;
                } else {
                    document.getElementById('status-hosted').textContent = '‚ö†Ô∏è No issuer URL found';
                }
            }
        }
        
        function getNested(obj, path) {
            return path.split('.').reduce((o, key) => (o && o[key] !== undefined ? o[key] : undefined), obj);
        }
        
        function showImageModal(src) {
            const modal = document.getElementById('image-viewer-modal');
            modal.innerHTML = document.getElementById('image-viewer-modal-template').innerHTML;
            modal.querySelector('#image-viewer-img').src = src;
            const downloadLink = modal.querySelector('#image-download-link');
            downloadLink.href = src;
            downloadLink.download = 'badge-image.png';
            modal.querySelector('#image-close-btn').onclick = () => modal.classList.add('hidden');
            modal.classList.remove('hidden');
        }

        async function verifyUrl(url) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                return { success: response.ok, reason: response.ok ? 'OK' : `HTTP ${response.status}` };
            } catch (e) { return { success: false, reason: 'Network Error' }; }
        }

        async function verifyJws(jws, publicKeyUrl) {
            try {
                const parts = jws.split('.');
                if (parts.length !== 3) return { success: false, reason: 'Invalid JWS format' };
                const response = await fetch(publicKeyUrl, { mode: 'cors' });
                if (!response.ok) return { success: false, reason: `Could not fetch public key (HTTP ${response.status})` };
                const issuerProfile = await response.json();
                const publicKeyJwk = issuerProfile.publicKey;
                if(!publicKeyJwk) return { success: false, reason: 'Public key not found in issuer profile' };
                const publicKey = await window.crypto.subtle.importKey("jwk", publicKeyJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
                const dataToVerify = new TextEncoder().encode(`${parts[0]}.${parts[1]}`);
                const signature = new Uint8Array(atob(parts[2].replace(/-/g, '+').replace(/_/g, '/')).split('').map(c => c.charCodeAt(0)));
                const isValid = await window.crypto.subtle.verify({ name: "ECDSA", hash: { name: "SHA-256" } }, publicKey, signature, dataToVerify);
                return { success: isValid, reason: isValid ? 'OK' : 'Signature mismatch' };
            } catch (e) {
                console.error("JWS Verification failed:", e);
                return { success: false, reason: e.message };
            }
        }

        async function handleVerifyRecipient() {
            if (!currentAssertionData) return;
            const emailToVerify = document.getElementById('verify-email-input').value;
            const recipientVerificationResult = document.getElementById('recipient-verification-result');
            if (!emailToVerify) {
                recipientVerificationResult.textContent = "Please enter an email to verify.";
                return;
            }
            try {
                const { salt, identity } = currentAssertionData.recipient;
                if (!salt || !identity) throw new Error("Recipient data is incomplete.");
                const expectedHash = identity.split('$')[1] || identity;
                const newHash = (await hashRecipient(emailToVerify, salt)).identity.split('$')[1];
                if (newHash === expectedHash) {
                    recipientVerificationResult.textContent = `‚úÖ Verified for: ${escapeHtml(emailToVerify)}`;
                    recipientVerificationResult.style.color = 'green';
                } else {
                    recipientVerificationResult.textContent = `‚ùå Verification failed for: ${escapeHtml(emailToVerify)}`;
                    recipientVerificationResult.style.color = 'red';
                }
            } catch (e) {
                recipientVerificationResult.textContent = `Could not perform verification: ${e.message}`;
                recipientVerificationResult.style.color = 'red';
            }
        }
        
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        async function hashRecipient(email, salt = `salt-${Date.now()}`) {
            const identityStr = email + salt;
            const data = new TextEncoder().encode(identityStr);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return { type: 'email', hashed: true, salt: salt, identity: `sha256$${hashArray.map(b => b.toString(16).padStart(2, '0')).join('')}` };
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0; return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        
        function extractBadgeData(pngBytes) {
            const decoder = new TextDecoder(); let offset = 8;
            while (offset < pngBytes.length) {
                const view = new DataView(pngBytes.buffer);
                const len = view.getUint32(offset, false);
                const type = decoder.decode(pngBytes.slice(offset + 4, offset + 8));
                if ((type === 'tEXt' || type === 'iTXt') && len > 10) {
                    const chunkData = pngBytes.slice(offset + 8, offset + 8 + len);
                    const nullIndex = chunkData.indexOf(0);
                    if (nullIndex > 0) {
                        const keyword = decoder.decode(chunkData.slice(0, nullIndex));
                        if (keyword === 'openbadges') {
                            let dataOffset = nullIndex + 1;
                            if (type === 'iTXt') { dataOffset += 2; while (chunkData[dataOffset] !== 0) dataOffset++; dataOffset++; while (chunkData[dataOffset] !== 0) dataOffset++; dataOffset++; }
                            const assertionText = decoder.decode(chunkData.slice(dataOffset));
                            const isSigned = assertionText.split('.').length === 3 && assertionText.startsWith('ey');
                            let assertion;
                            if (isSigned) {
                                try { assertion = JSON.parse(atob(assertionText.split('.')[1].replace(/-/g, '+').replace(/_/g, '/'))); }
                                catch (e) { assertion = { error: "Could not decode JWS payload", jws: assertionText }; }
                            } else {
                                assertion = JSON.parse(assertionText);
                            }
                            return { assertion, isSigned, jws: isSigned ? assertionText : null };
                        }
                    }
                }
                if (type === 'IEND') break;
                offset += 12 + len;
            }
            return { assertion: null };
        }

        async function bakePng(base64Png, assertion, isSigned) {
            const pngHeader = "data:image/png;base64,";
            if (!base64Png || !base64Png.startsWith(pngHeader)) {
                throw new Error("Invalid or missing base64 PNG data for baking.");
            }
            const pngData = atob(base64Png.substring(pngHeader.length));
            const pngBytes = new Uint8Array(pngData.length);
            for (let i = 0; i < pngData.length; i++) pngBytes[i] = pngData.charCodeAt(i);
            
            const keyword = "openbadges"; 
            const text = isSigned ? assertion : JSON.stringify(assertion);
            const encoder = new TextEncoder();
            const keywordBytes = encoder.encode(keyword); const textBytes = encoder.encode(text);
            const chunkData = new Uint8Array(keywordBytes.length + 1 + textBytes.length);
            chunkData.set(keywordBytes, 0); chunkData[keywordBytes.length] = 0;
            chunkData.set(textBytes, keywordBytes.length + 1);
            const chunkType = new Uint8Array([116, 69, 88, 116]);
            const chunkLength = chunkData.length;
            const fullChunk = new Uint8Array(4 + 4 + chunkLength + 4);
            const view = new DataView(fullChunk.buffer);
            view.setUint32(0, chunkLength, false);
            fullChunk.set(chunkType, 4); fullChunk.set(chunkData, 8);
            const crcData = new Uint8Array(4 + chunkLength);
            crcData.set(chunkType, 0); crcData.set(chunkData, 4);
            view.setUint32(8 + chunkLength, crc32(crcData), false);
            
            let iendOffset = -1;
            for (let i = 8; i < pngBytes.length;) {
                const len = (new DataView(pngBytes.buffer)).getUint32(i, false);
                const type = new TextDecoder().decode(pngBytes.slice(i + 4, i + 8));
                if (type === 'IEND') { iendOffset = i; break; }
                i += 12 + len;
            }
            if (iendOffset === -1) throw new Error("Could not find IEND chunk in PNG.");

            const newPngBytes = new Uint8Array(pngBytes.length + fullChunk.length);
            newPngBytes.set(pngBytes.slice(0, iendOffset), 0);
            newPngBytes.set(fullChunk, iendOffset);
            newPngBytes.set(pngBytes.slice(iendOffset), iendOffset + fullChunk.length);
            
            let newPngData = '';
            for (let i = 0; i < newPngBytes.length; i++) newPngData += String.fromCharCode(newPngBytes[i]);
            return pngHeader + btoa(newPngData);
        }

        const crcTable = (() => {
            const table = new Int32Array(256);
            for(let n = 0; n < 256; n++) { let c = n; for(let k = 0; k < 8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1)); table[n] = c; }
            return table;
        })();
        function crc32(bytes) {
            let crc = -1;
            for (let i = 0; i < bytes.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
            return (crc ^ -1) >>> 0;
        }

        async function autoLoadConfig() {
            try {
                const encryptedResponse = await fetch('config.encrypted.json');
                if (encryptedResponse.ok) {
                    const encryptedContent = await encryptedResponse.text();
                    await processUploadedConfig(encryptedContent);
                    return; 
                }
            } catch (e) { /* Fall through to plain config */ }
            
            try {
                const plainResponse = await fetch('config.json');
                if (plainResponse.ok) {
                    const plainContent = await plainResponse.text();
                    await processUploadedConfig(plainContent);
                }
            } catch (e) {
                console.error("Could not auto-load any config file:", e);
            }
        }
        autoLoadConfig();

    });
    </script>
</body>
</html>
