<!DOCTYPE html>
<!--
Copyright (C) 2025 KSEC - Erez Kalman. All Rights Reserved.

SPDX-License-Identifier: (AGPL-3.0-or-later OR LicenseRef-Erez_Kalman_KSEC-Commercial)

This source code is licensed under a dual-license model.
See the LICENSE, and LICENSE.AGPL.md files for full details.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open Badge Management Suite</title>
    <link rel="icon" href="favicon.ico" sizes="32x32">
    <style>
        :root { --primary-color: #007bff; --primary-hover: #0056b3; --border-color: #dee2e6; --danger-color: #dc3545; --success-color: #28a745; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f9; color: #333; margin: 0; padding: 20px; }
        main { max-width: 900px; margin: 20px auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        h1, h2, h3, h4 { color: #0056b3; border-bottom: 2px solid #eef; padding-bottom: 10px; }
        h4 { border-bottom: 1px dashed #eef; }
        section { margin-bottom: 30px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; color: #555; }
        input[type="text"], input[type="email"], input[type="date"], input[type="password"], input[type="number"], input[type="url"], select, textarea { width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-family: inherit; }
        textarea { min-height: 100px; font-family: inherit; resize: vertical; }
        textarea.code { font-family: "Courier New", Courier, monospace; }
        #json-viewer-modal textarea { height: 300px; font-family: "Courier New", Courier, monospace; }
        button, .download-link { display: inline-block; background-color: var(--primary-color); color: white; padding: 12px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; transition: background-color 0.3s; margin-right: 10px; margin-top: 5px; text-decoration: none; font-family: inherit; }
        button:hover, .download-link:hover { background-color: var(--primary-hover); color: white; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        button.secondary { background-color: #6c757d; }
        button.secondary:hover { background-color: #5a6268; }
        button.danger { background-color: var(--danger-color); }
        button.danger:hover { background-color: #c82333; }
        button.success { background-color: var(--success-color); }
        button.success:hover { background-color: #218838; }
        pre { background-color: #eee; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-family: "Courier New", Courier, monospace; max-height: 300px; overflow-y: auto; }
        .tabs { border-bottom: 2px solid var(--border-color); margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        .tabs .tab-buttons { display: flex; }
        .tabs button { background-color: transparent; border: none; padding: 10px 15px; cursor: pointer; font-size: 18px; color: #0056b3; border-bottom: 3px solid transparent; }
        .tabs button.active { border-bottom: 3px solid var(--primary-color); font-weight: bold; }
        .tabs button:disabled { color: #6c757d; cursor: not-allowed; }
        .error-message { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        .warning-message { color: #856404; background-color: #fff3cd; border: 1px solid #ffeeba; padding: 10px; border-radius: 4px; margin-top: 10px;}
        .success-message { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        .info-message { color: #004085; background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 10px; border-radius: 4px; margin-bottom: 15px; }
        fieldset { border: 1px solid #ccc; border-radius: 4px; padding: 15px; margin-bottom: 20px; }
        legend { font-weight: bold; color: var(--primary-color); padding: 0 10px; }
        details { margin-bottom: 10px; border: 1px solid #eee; padding: 5px; border-radius: 4px;}
        summary { cursor: pointer; font-weight: normal; color: #555; font-size: 0.9em;}
        .badge-entry { border: 1px dashed #ccc; padding: 15px; margin-bottom: 15px; border-radius: 4px; }
        .modal { position: fixed; z-index: 100; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 30px; border-radius: 8px; width: 90%; max-width: 600px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content.image-viewer { max-width: 90vw; max-height: 90vh; overflow: auto; }
        .modal-content.image-viewer img { max-width: 100%; height: auto; }
        .verification-result { margin-top: 10px; font-weight: bold; }
        .input-group { position: relative; }
        .toggle-visibility { position: absolute; right: 10px; top: 10px; cursor: pointer; user-select: none; font-style: normal; }
        .image-manager { display: flex; align-items: flex-start; gap: 15px; }
        .image-manager img { max-width: 100px; height: auto; border: 1px solid #ddd; }
        .image-manager .controls { flex-grow: 1; }
        .custom-field { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; margin-bottom: 10px; align-items: start; }
        .custom-field-radios { grid-column: 1 / -1; display: flex; justify-content: flex-start; gap: 15px; font-size: 0.8em; margin-top: -10px; margin-bottom: 5px; }
        .custom-field-radios label { font-weight: normal; }
        .custom-field input { margin-bottom: 0; }
        .summary-table { width: 100%; border-collapse: collapse; margin-top: 15px; text-align: left;}
        .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
        .summary-table th { background-color: #f2f2f2; width: 30%; }
        .summary-table img { max-width: 60px; cursor: pointer; transition: transform 0.2s; }
        .summary-table img:hover { transform: scale(1.1); }
        .summary-table h4 { margin: 10px 0 5px; border: none; }
        footer { text-align: center; margin-top: 30px; color: #6c757d; font-size: 0.9em; }
        .hidden { display: none; }
        .dynamic-bake-field { display: flex; align-items: center; gap: 10px; }
        .dynamic-bake-field label { flex-shrink: 0; }
        .dynamic-bake-field input { flex-grow: 1; }
        .url-fields { background-color: #f8f9fa; padding: 15px; border-radius: 4px; margin-bottom: 15px; }
        .url-fields h5 { margin-top: 0; color: #0056b3; }
        .export-buttons { display: flex; gap: 10px; margin-top: 10px; }
        .version-info { font-size: 0.9em; color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>
    <main>
        <h1>Open Badge Management Suite üèÖ</h1>
        <div class="version-info">Open Badges 2.0 Compliant ‚Ä¢ Version 2.0.0</div>
        
        <div class="tabs">
            <div class="tab-buttons">
                <button id="manager-tab-btn" class="active">Issuer Management</button>
                <button id="baker-tab-btn" disabled title="Load or create a configuration first">Bake a Badge</button>
                <button id="verify-tab-btn">Verify a Badge</button>
            </div>
            <button id="clear-session-btn" class="secondary hidden">Clear & Lock</button>
        </div>

        <div id="manager-view">
            <section id="config-loader-section">
                <h2>Load or Create Configuration</h2>
                <p>Load a plain or encrypted <strong>config.json</strong> file, or create a new configuration from scratch.</p>
                <input type="file" id="configFile" accept=".json">
                <button type="button" id="create-new-config-btn">Create New Config</button>
                <div id="config-error" class="error-message hidden"></div>
            </section>
            <section id="manager-form-section" class="hidden">
                <form id="manager-form">
                    <fieldset>
                        <legend>Issuer Details</legend>
                        <div id="issuer-fields"></div>
                        <div id="issuer-custom-fields" class="custom-fields-container"></div>
                        <button type="button" class="add-custom-field-btn" data-target="issuer-custom-fields" data-prefix="issuer-custom">Add Custom Field</button>
                        <div class="url-fields" id="issuer-url-fields">
                            <h5>Hosting URLs (Required for Signed Badges)</h5>
                            <label for="issuer-profile-url">Issuer Profile URL:</label>
                            <input type="url" id="issuer-profile-url" placeholder="https://yourdomain.com/badges/issuer.json">
                            <label for="issuer-publickey-url">Public Key URL:</label>
                            <input type="url" id="issuer-publickey-url" placeholder="https://yourdomain.com/badges/public-key.json">
                            <div class="export-buttons">
                                <button type="button" id="generate-issuer-json-btn" class="secondary">Export Issuer JSON</button>
                                <button type="button" id="generate-publickey-json-btn" class="secondary">Export Public Key JSON</button>
                            </div>
                            <div class="info-message">Export these files and host them at the URLs specified above for signed badge support.</div>
                        </div>
                    </fieldset>
                    <fieldset>
                        <legend>Badge Classes</legend>
                        <div class="info-message">
                            <strong>Formatting Tips:</strong> Description and criteria fields support line breaks and basic Markdown formatting (bold, italic, lists). Many badge displayers will render Markdown appropriately.
                        </div>
                        <div id="badges-container"></div>
                        <button type="button" id="add-badge-btn">Add Another Badge</button>
                    </fieldset>
                    <hr>
                    <fieldset>
                        <legend>Export Options</legend>
                        <label for="config-version">Configuration Version:</label>
                        <input type="text" id="config-version" value="2.0.0" placeholder="e.g., 2.0.0">
                        <label for="kdf-iterations">PBKDF2 Iterations (for encryption):</label>
                        <input type="number" id="kdf-iterations" value="250000" min="10000">
                        <details><summary>Help</summary><p>Higher numbers increase security against brute-force attacks but make encryption/decryption slower. 250,000 is a strong default.</p></details>
                        <button type="button" id="export-plain-btn">Export as Plain JSON</button>
                        <button type="button" id="export-encrypted-btn">Export as Encrypted JSON</button>
                        <div id="validation-status" class="hidden"></div>
                    </fieldset>
                </form>
            </section>
        </div>
        <div id="baker-view" class="hidden"></div>
        <div id="verifier-view" class="hidden"></div>
    </main>

    <div id="password-modal" class="modal hidden"></div>
    <div id="json-viewer-modal" class="modal hidden"></div>
    <div id="image-viewer-modal" class="modal hidden"></div>
    
    <template id="baker-template">
        <section>
            <h2>Issue a Badge</h2>
            <form id="baker-form">
                <div id="baker-error" class="error-message hidden"></div>
                <label for="badge-select">Select Badge:</label>
                <select id="badge-select" required></select>
                
                <div id="dynamic-bake-fields"></div>

                <label for="recipient-email">Recipient Email:</label>
                <input type="email" id="recipient-email" placeholder="jane.doe@example.com" required>
                <label for="evidence-url">Evidence URL (Optional):</label>
                <input type="text" id="evidence-url" placeholder="https://github.com/janedoe/project">
                <label for="issued-date">Issue Date:</label>
                <input type="date" id="issued-date" required>
                <label>Expiration:</label>
                <div><label><input type="radio" name="expiration" value="no" checked> No Expiration</label><label><input type="radio" name="expiration" value="yes"> Set Date</label></div>
                <input type="date" id="expires-date" class="hidden">
                <label>Verification Type:</label>
                <div id="verification-type-options">
                    <label><input type="radio" name="verification" value="embedded" checked> Embedded (Baked)</label>
                    <label><input type="radio" name="verification" value="signed" id="signed-option"> Signed</label>
                </div>
                <div id="signing-requirements-warning" class="warning-message hidden">
                    ‚ö†Ô∏è Signed badges require: issuer URLs, public/private keys. Missing requirements - please complete in Issuer Management.
                </div>
                <button type="submit">Bake Badge</button>
                <button type="button" id="validate-before-bake" class="secondary">Validate Structure</button>
            </form>
        </section>
        <section id="result-section" class="hidden">
            <h3>Baked Badge Result</h3>
            <img id="preview-img" style="max-width: 200px; border: 1px solid #ddd; border-radius: 4px;">
            <br>
            <a id="download-link" class="download-link" href="#" download="baked-badge.png">Download Baked Badge</a>
            <button type="button" id="validate-result-btn" class="success">Validate with Spec</button>
            <div id="validation-result" class="hidden"></div>
            <pre><code id="json-output"></code></pre>
        </section>
    </template>
    
    <template id="verifier-template">
         <section>
            <h2>Badge Verifier</h2>
            <p>Verification is performed offline. For richer details, you may optionally provide the Issuer and BadgeClass JSON files.</p>
            <label for="verifyFile">Upload Badge Image (PNG):</label>
            <input type="file" id="verifyFile" accept=".png">
            <details>
                <summary>Issuer JSON (Optional)</summary>
                <label for="verifyIssuerFile">Upload Issuer JSON file:</label>
                <input type="file" id="verifyIssuerFile" accept=".json">
                <label for="verifyIssuerText">Or paste Issuer JSON here:</label>
                <textarea id="verifyIssuerText" rows="3"></textarea>
            </details>
             <details>
                <summary>BadgeClass JSON (Optional)</summary>
                <label for="verifyBadgeFile">Upload BadgeClass JSON file:</label>
                <input type="file" id="verifyBadgeFile" accept=".json">
                <label for="verifyBadgeText">Or paste BadgeClass JSON here:</label>
                <textarea id="verifyBadgeText" rows="3"></textarea>
            </details>
            <div id="verify-error" class="error-message hidden"></div>
            <div id="verify-summary" class="hidden">
                <h3>Badge Summary</h3>
                <div id="verify-summary-table"></div>
                <div id="recipient-verification-section" class="hidden">
                    <h3>Verify Recipient</h3>
                    <input type="email" id="verify-email-input" placeholder="Enter recipient's email to verify identity">
                    <button id="verify-recipient-btn">Verify Recipient</button>
                    <div id="recipient-verification-result" class="verification-result"></div>
                </div>
                <button id="toggle-json-btn" style="margin-top: 15px;">Show/Hide Full Assertion</button>
            </div>
            <pre id="verify-output" class="hidden"></pre>
        </section>
    </template>

    <template id="password-modal-template">
        <div class="modal-content">
            <h3 id="modal-title">Enter Password</h3>
            <div id="modal-warning" class="warning-message hidden"></div>
            <div id="modal-error" class="error-message hidden"></div>
            <input type="password" id="modal-password" placeholder="Password">
            <input type="password" id="modal-confirm-password" placeholder="Confirm Password" class="hidden">
            <button id="modal-submit">Submit</button>
            <button id="modal-cancel" class="secondary">Cancel</button>
        </div>
    </template>

    <template id="json-viewer-modal-template">
        <div class="modal-content">
            <h3 id="json-viewer-title">Generated JSON</h3>
            <textarea id="json-viewer-content" readonly></textarea>
            <br>
            <button id="json-download-btn">Download</button>
            <button id="json-close-btn" class="secondary">Close</button>
        </div>
    </template>

    <template id="image-viewer-modal-template">
        <div class="modal-content image-viewer">
            <img id="image-viewer-img" src="">
            <br>
            <a id="image-download-link" class="download-link" href="#">Download Image</a>
            <button id="image-close-btn" class="secondary">Close</button>
        </div>
    </template>
    
    <footer>(C) 2025 KSEC - Erez Kalman</footer>

    <script>
    window.addEventListener('DOMContentLoaded', () => {
        let config = null;
        let currentAssertionData = null;
        const CONFIG_VERSION = '2.0.0';

        const tabs = {
            manager: { btn: document.getElementById('manager-tab-btn'), view: document.getElementById('manager-view') },
            baker:   { btn: document.getElementById('baker-tab-btn'),   view: document.getElementById('baker-view') },
            verify:  { btn: document.getElementById('verify-tab-btn'), view: document.getElementById('verifier-view') }
        };
        const configFile = document.getElementById('configFile');
        const configLoaderSection = document.getElementById('config-loader-section');
        const managerFormSection = document.getElementById('manager-form-section');
        const createNewConfigBtn = document.getElementById('create-new-config-btn');
        const clearSessionBtn = document.getElementById('clear-session-btn');
        const passwordModal = document.getElementById('password-modal');
        const configError = document.getElementById('config-error');

        initializeViewsAndListeners();

        document.querySelector('.tabs .tab-buttons').addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON') {
                const tabName = event.target.id.split('-')[0];
                switchTab(tabName);
            }
        });

        configFile.addEventListener('change', handleConfigFile);
        createNewConfigBtn.addEventListener('click', createNewConfig);
        clearSessionBtn.addEventListener('click', clearSession);
        
        function initializeViewsAndListeners() {
            tabs.baker.view.innerHTML = document.getElementById('baker-template').innerHTML;
            tabs.verify.view.innerHTML = document.getElementById('verifier-template').innerHTML;
            passwordModal.innerHTML = document.getElementById('password-modal-template').innerHTML;
            attachDynamicListeners();
            managerFormSection.addEventListener('click', (e) => {
                if (e.target.matches('.add-custom-field-btn')) {
                    addCustomFieldInput(e.target.dataset.target, e.target.dataset.prefix);
                } else if (e.target.matches('#add-badge-btn')) {
                    addBadgeEntry();
                } else if (e.target.matches('#export-plain-btn')) {
                    handleExportPlain();
                } else if (e.target.matches('#export-encrypted-btn')) {
                    handleExportEncrypted();
                } else if (e.target.matches('#generate-issuer-json-btn')) {
                    generateSingleJson('issuer');
                } else if (e.target.matches('#generate-publickey-json-btn')) {
                    generateSingleJson('publickey');
                } else if (e.target.matches('.remove-badge-btn')) {
                    e.target.closest('.badge-entry').remove();
                } else if (e.target.matches('.duplicate-badge-btn')) {
                    duplicateBadge(e.target.closest('.badge-entry'));
                } else if (e.target.matches('.generate-badge-json-btn')) {
                    const index = e.target.closest('.badge-entry').dataset.index;
                    generateSingleJson('badge', index);
                } else if (e.target.matches('.generate-badge-json-btn')) {
                    const index = e.target.closest('.badge-entry').dataset.index;
                    generateSingleJson('badge', index);
                }
            });
            managerFormSection.addEventListener('input', (e) => {
                if (e.target.matches('#issuer-profile-url') || e.target.matches('#issuer-publickey-url') || e.target.matches('#issuer-privateKey')) {
                    updateSigningCapability();
                }
            });
        }
        
        function switchTab(tabName) {
            if (!tabs[tabName] || tabs[tabName].btn.disabled) return;
            Object.values(tabs).forEach(tab => {
                tab.view.classList.add('hidden');
                tab.btn.classList.remove('active');
            });
            tabs[tabName].view.classList.remove('hidden');
            tabs[tabName].btn.classList.add('active');
        }
        
        function displayError(element, message) {
            element.textContent = message;
            element.classList.remove('hidden');
        }

        function displaySuccess(element, message) {
            element.textContent = message;
            element.className = 'success-message';
            element.classList.remove('hidden');
        }

        function createNewConfig() {
            const defaultConfig = {
                version: CONFIG_VERSION,
                issuer: { 
                    name: "", 
                    email: "", 
                    url: "",
                    description: "",
                    profileUrl: "",
                    publicKeyUrl: ""
                },
                badges: [{ 
                    alias: "", 
                    name: "", 
                    description: "", 
                    criteria: "", 
                    image_base_64: "", 
                    tags: "", 
                    issuerType: "embedded" 
                }]
            };
            processConfig(JSON.stringify(defaultConfig));
        }

        async function handleConfigFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                displayError(configError, "Invalid file type. Please upload a JSON file.");
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => await processUploadedConfig(e.target.result);
            reader.readAsText(file);
        }

        async function processUploadedConfig(content) {
            try {
                const parsedJson = JSON.parse(content);
                if (parsedJson.metadata && parsedJson.encryptedData) {
                    const password = await promptForPassword('Decrypt Configuration');
                    if (!password) return;
                    let decryptedText;
                    try {
                        decryptedText = await decryptData(parsedJson, password);
                    } catch (e) {
                        throw new Error("Decryption failed. Please check your password or the file may be corrupt.");
                    }
                    processConfig(decryptedText);
                } else {
                    processConfig(content);
                }
            } catch (err) {
                displayError(configError, `Error processing file: ${err.message}`);
            }
        }

        function processConfig(configText) {
            configError.classList.add('hidden');
            try {
                config = JSON.parse(configText);
                
                // Migrate old configs to new version
                if (!config.version) {
                    config.version = CONFIG_VERSION;
                    if (!config.issuer.profileUrl) config.issuer.profileUrl = "";
                    if (!config.issuer.publicKeyUrl) config.issuer.publicKeyUrl = "";
                }
                
                if (!config.issuer || !config.badges) throw new Error("Config must contain 'issuer' and 'badges' keys.");
                
                populateManagerForm(config);
                populateBadgeSelector(config.badges);
                updateSigningCapability();

                configLoaderSection.classList.add('hidden');
                managerFormSection.classList.remove('hidden');
                tabs.baker.btn.disabled = false;
                tabs.baker.btn.title = "Bake a Badge";
                clearSessionBtn.classList.remove('hidden');
                switchTab('manager');
            } catch (error) {
                displayError(configError, `Error processing config file: ${error.message}`);
            }
        }

        function populateManagerForm(data) {
            const definedIssuerKeys = ['name', 'url', 'email', 'description', 'image_base_64', 'publicKey', 'privateKey'];
            const standardIssuerFields = {};
            const customIssuerFields = (data.issuer.customFields || {});
            for (const key in data.issuer) {
                if (definedIssuerKeys.includes(key)) standardIssuerFields[key] = data.issuer[key];
            }
            
            document.getElementById('issuer-fields').innerHTML = createFormFields(standardIssuerFields, 'issuer');
            
            // Populate URL fields
            document.getElementById('issuer-profile-url').value = data.issuer.profileUrl || '';
            document.getElementById('issuer-publickey-url').value = data.issuer.publicKeyUrl || '';
            document.getElementById('config-version').value = data.version || CONFIG_VERSION;
            
            const issuerCustomContainer = document.getElementById('issuer-custom-fields');
            issuerCustomContainer.innerHTML = '';
            for (const key in customIssuerFields) {
                addCustomFieldInput('issuer-custom-fields', 'issuer-custom', key, customIssuerFields[key].value, customIssuerFields[key].type);
            }
            
            const genKeyBtn = document.getElementById('generate-key-btn');
            if (genKeyBtn) genKeyBtn.addEventListener('click', generateKeyPair);
            
            const togglePkBtn = document.getElementById('toggle-pk-visibility');
            if (togglePkBtn) togglePkBtn.addEventListener('click', togglePrivateKeyVisibility);

            const issuerImgUpload = document.getElementById('issuer-image_base_64-upload');
            if (issuerImgUpload) issuerImgUpload.addEventListener('change', (e) => handleImageUpload(e, 'issuer-image_base_64-preview', 'issuer-image_base_64'));
            
            const badgesContainer = document.getElementById('badges-container');
            badgesContainer.innerHTML = '';
            data.badges.forEach((badge, index) => addBadgeEntry(badge, index));
        }

        function addBadgeEntry(badgeData = {}, index = -1) {
            const badgesContainer = document.getElementById('badges-container');
            const badgeIndex = index === -1 ? badgesContainer.children.length : index;
            
            const definedBadgeKeys = ['alias', 'name', 'description', 'criteria', 'image_base_64', 'tags', 'issuerType'];
            const standardBadgeFields = {};
            const customBadgeFields = (badgeData.customFields || {});
            for (const key in badgeData) {
                if (definedBadgeKeys.includes(key)) standardBadgeFields[key] = badgeData[key];
            }

            const entryDiv = document.createElement('div');
            entryDiv.className = 'badge-entry';
            entryDiv.dataset.index = badgeIndex;
            entryDiv.innerHTML = `
                <h4>Badge ${badgeIndex + 1}</h4>
                <div class="standard-fields">${createFormFields(standardBadgeFields, `badge-${badgeIndex}`)}</div>
                <div id="badge-${badgeIndex}-custom-fields" class="custom-fields-container"></div>
                <button type="button" class="add-custom-field-btn" data-target="badge-${badgeIndex}-custom-fields" data-prefix="badge-${badgeIndex}-custom">Add Custom Field</button>
                <button type="button" class="secondary duplicate-badge-btn">Duplicate Badge</button>
                <button type="button" class="danger remove-badge-btn">Remove Badge</button>
                <details style="margin-top: 10px;">
                    <summary>Advanced Options</summary>
                    <button type="button" class="secondary generate-badge-json-btn" style="margin-top: 5px;">Generate BadgeClass JSON</button>
                    <p style="font-size: 0.9em; color: #666;">Export this BadgeClass for hosting or use in other systems.</p>
                </details>
            `;
            badgesContainer.appendChild(entryDiv);
            
            const badgeCustomContainer = entryDiv.querySelector(`#badge-${badgeIndex}-custom-fields`);
            for (const key in customBadgeFields) {
                addCustomFieldInput(`badge-${badgeIndex}-custom-fields`, `badge-${badgeIndex}-custom`, key, customBadgeFields[key].value, customBadgeFields[key].type);
            }
            
            const badgeImgUpload = entryDiv.querySelector(`#badge-${badgeIndex}-image_base_64-upload`);
            if (badgeImgUpload) badgeImgUpload.addEventListener('change', (e) => handleImageUpload(e, `badge-${badgeIndex}-image_base_64-preview`, `badge-${badgeIndex}-image_base_64`));
        }

        function duplicateBadge(originalEntry) {
            const badgesContainer = document.getElementById('badges-container');
            const originalIndex = originalEntry.dataset.index;
            
            // Extract data from original badge
            const badgeData = {};
            originalEntry.querySelectorAll('.standard-fields .form-field').forEach(input => {
                const key = input.id.replace(`badge-${originalIndex}-`, '');
                badgeData[key] = input.value;
            });
            
            const issuerTypeInput = originalEntry.querySelector(`input[name="badge-${originalIndex}-issuerType"]:checked`);
            if(issuerTypeInput) badgeData.issuerType = issuerTypeInput.value;
            
            // Extract custom fields
            badgeData.customFields = {};
            originalEntry.querySelectorAll(`#badge-${originalIndex}-custom-fields .custom-field`).forEach(div => {
                const keyInput = div.querySelector('[data-custom-key]');
                const valueInput = div.querySelector('[data-custom-value]');
                const typeInput = div.querySelector('input[type="radio"]:checked');
                if (keyInput && valueInput && typeInput && keyInput.value) {
                    badgeData.customFields[keyInput.value] = {
                        type: typeInput.value,
                        value: valueInput.value
                    };
                }
            });
            
            // Modify alias to make it unique
            badgeData.alias = badgeData.alias + '-copy';
            badgeData.name = badgeData.name + ' (Copy)';
            
            // Add the new badge after the original
            const newIndex = badgesContainer.children.length;
            addBadgeEntry(badgeData, newIndex);
            
            // Scroll to the new badge
            const newEntry = badgesContainer.lastElementChild;
            newEntry.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function addCustomFieldInput(targetId, prefix, key = '', value = '', type = 'global') {
            const container = document.getElementById(targetId);
            const fieldIndex = Date.now() + Math.random();
            const div = document.createElement('div');
            div.className = 'custom-field';

            const radioName = `${prefix}-radios-${fieldIndex}`;
            div.innerHTML = `
                <div>
                    <input type="text" class="form-field" data-custom-key="true" placeholder="Field Name (e.g., version)" value="${escapeHtml(key)}">
                    <input type="text" class="form-field" data-custom-value="true" placeholder="Field Value" value="${escapeHtml(value)}">
                </div>
                <div class="custom-field-radios">
                    <label><input type="radio" name="${radioName}" value="global" ${type === 'global' ? 'checked' : ''}> Global</label>
                    <label><input type="radio" name="${radioName}" value="baking-optional" ${type === 'baking-optional' ? 'checked' : ''}> Baking - Optional</label>
                    <label><input type="radio" name="${radioName}" value="baking-required" ${type === 'baking-required' ? 'checked' : ''}> Baking - Required</label>
                </div>
                <button type="button" class="danger">X</button>
            `;
            container.appendChild(div);
            div.querySelector('.danger').addEventListener('click', () => div.remove());
        }

        function createFormFields(data, prefix) {
            const fields = {
                issuer: { 
                    name: {r:true}, 
                    url: {r:true}, 
                    email: {r:false}, 
                    description: {r:false, t:'textarea', h:"Supports line breaks and basic Markdown"}, 
                    image_base_64: {r:false, t:'image'}, 
                    publicKey: {r:false, t:'textarea', h:"JWK format public key (will be exported separately)."}, 
                    privateKey: {r:false, t:'textarea', p:true, h:"Secret JWK for signing - never share!"} 
                },
                badge: { 
                    alias: {r:true, h:"Unique identifier for this badge"}, 
                    name: {r:true}, 
                    description: {r:true, t:'textarea', h:"Supports line breaks and basic Markdown"}, 
                    criteria: {r:true, t:'textarea', h:"What recipients must do to earn this badge. Supports line breaks and basic Markdown."}, 
                    image_base_64: {r:true, t:'image'}, 
                    tags: {r:false, h:"Comma-separated"}, 
                    issuerType: {r: true, t: 'radio', options: ['embedded', 'hosted']} 
                }
            };
            const fieldType = prefix.startsWith('badge') ? 'badge' : 'issuer';
            
            let html = Object.entries(fields[fieldType]).map(([key, opts]) => {
                const value = (data && data[key]) ? data[key] : '';
                let inputElement;
                if (opts.t === 'image') {
                    const placeholder = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    inputElement = `
                        <div class="image-manager">
                            <img id="${prefix}-${key}-preview" src="${value || placeholder}" alt="Image preview">
                            <div class="controls">
                                <input type="file" id="${prefix}-${key}-upload" accept="image/png,image/jpeg">
                                <textarea class="form-field hidden" id="${prefix}-${key}">${escapeHtml(value)}</textarea>
                            </div>
                        </div>`;
                } else if (opts.t === 'textarea') {
                    let placeholder = opts.h || '';
                    if (key === 'criteria') {
                        placeholder = 'e.g., Complete the following:\n\n1. **Pass** the final exam\n2. Submit *all* assignments\n3. Attend 80% of classes';
                    } else if (key === 'description' && fieldType === 'badge') {
                        placeholder = 'e.g., This badge recognizes **outstanding achievement** in...\n\nEarners have demonstrated:\n- Critical thinking\n- Problem solving';
                    }
                    const codeClass = (key === 'publicKey' || key === 'privateKey') ? ' code' : '';
                    inputElement = `<textarea class="form-field${codeClass}" id="${prefix}-${key}" ${opts.r ? 'required' : ''} placeholder="${placeholder}">${escapeHtml(value)}</textarea>`;
                } else if (opts.t === 'radio') {
                    inputElement = `<div id="${prefix}-${key}" class="issuer-type-radios">
                        <label><input type="radio" name="${prefix}-${key}" value="embedded" ${value === 'embedded' || !value ? 'checked' : ''}> Embedded Issuer</label>
                        <label><input type="radio" name="${prefix}-${key}" value="hosted" ${value === 'hosted' ? 'checked' : ''}> Hosted Issuer (requires issuer URL)</label>
                    </div>`;
                } else {
                    inputElement = `<input type="${opts.p ? 'password' : 'text'}" class="form-field" id="${prefix}-${key}" value="${escapeHtml(value)}" ${opts.r ? 'required' : ''} placeholder="${opts.h || ''}">`;
                }
                
                const visibilityToggle = opts.p ? `<i class="toggle-visibility" id="toggle-pk-visibility">üëÅÔ∏è</i>` : '';
                const inputGroup = opts.p ? `<div class="input-group">${inputElement}${visibilityToggle}</div>` : inputElement;
                const warning = key === 'privateKey' ? `<div class="warning-message"><strong>Warning:</strong> Your private key is a secret. The plain-text export will omit this key.</div>` : '';
                return `<label for="${prefix}-${key}">${key.replace(/_/g, ' ')}${opts.r ? ' *' : ''}</label>${inputGroup}${warning}`;
            }).join('');

            if (fieldType === 'issuer') {
                html += `<button type="button" id="generate-key-btn" class="secondary">Generate New Key Pair</button>`;
            }
            return html;
        }
        
        function updateSigningCapability() {
            const profileUrl = document.getElementById('issuer-profile-url').value;
            const publicKeyUrl = document.getElementById('issuer-publickey-url').value;
            const privateKey = document.getElementById('issuer-privateKey').value;
            
            const canSign = profileUrl && publicKeyUrl && privateKey;
            const signedOption = document.getElementById('signed-option');
            const warningDiv = document.getElementById('signing-requirements-warning');
            
            if (signedOption) {
                signedOption.disabled = !canSign;
                if (!canSign && signedOption.checked) {
                    document.querySelector('input[name="verification"][value="embedded"]').checked = true;
                }
                warningDiv.classList.toggle('hidden', canSign);
            }
        }

        function handleImageUpload(event, previewId, textareaId) {
            const file = event.target.files[0];
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById(previewId).src = e.target.result;
                document.getElementById(textareaId).value = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function togglePrivateKeyVisibility() {
            const pkInput = document.getElementById('issuer-privateKey');
            pkInput.type = pkInput.type === 'password' ? 'text' : 'password';
        }

        async function generateKeyPair() {
            try {
                const keyPair = await window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, true, ["sign", "verify"]);
                const publicKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.publicKey);
                const privateKeyJwk = await window.crypto.subtle.exportKey("jwk", keyPair.privateKey);
                document.getElementById('issuer-publicKey').value = JSON.stringify(publicKeyJwk, null, 2);
                document.getElementById('issuer-privateKey').value = JSON.stringify(privateKeyJwk, null, 2);
                alert("New key pair generated and populated in the form.");
            } catch (e) {
                alert(`Key generation failed: ${e.message}`);
            }
        }

        function extractDataFromForm() {
            const newConfig = { 
                version: document.getElementById('config-version').value || CONFIG_VERSION,
                issuer: { 
                    customFields: {},
                    profileUrl: document.getElementById('issuer-profile-url').value,
                    publicKeyUrl: document.getElementById('issuer-publickey-url').value
                }, 
                badges: [] 
            };
            
            document.querySelectorAll('#issuer-fields .form-field').forEach(input => {
                const key = input.id.replace('issuer-', '');
                if(input.value && !input.dataset.customKey && !input.dataset.customValue) newConfig.issuer[key] = input.value;
            });
            document.querySelectorAll('#issuer-custom-fields .custom-field').forEach(div => {
                const keyInput = div.querySelector('[data-custom-key]');
                const valueInput = div.querySelector('[data-custom-value]');
                const typeInput = div.querySelector('input[type="radio"]:checked');
                if (keyInput && valueInput && typeInput && keyInput.value) {
                    newConfig.issuer.customFields[keyInput.value] = {
                        type: typeInput.value,
                        value: valueInput.value
                    };
                }
            });

            document.querySelectorAll('#badges-container .badge-entry').forEach(entry => {
                const badge = { customFields: {} };
                const index = entry.dataset.index;
                
                entry.querySelectorAll('.standard-fields .form-field').forEach(input => {
                    const key = input.id.replace(`badge-${index}-`, '');
                    if(input.value) badge[key] = input.value;
                });
                
                const issuerTypeInput = entry.querySelector(`input[name="badge-${index}-issuerType"]:checked`);
                if(issuerTypeInput) badge.issuerType = issuerTypeInput.value;

                entry.querySelectorAll(`#badge-${index}-custom-fields .custom-field`).forEach(div => {
                    const keyInput = div.querySelector('[data-custom-key]');
                    const valueInput = div.querySelector('[data-custom-value]');
                    const typeInput = div.querySelector('input[type="radio"]:checked');
                    if (keyInput && valueInput && typeInput && keyInput.value) {
                        badge.customFields[keyInput.value] = {
                            type: typeInput.value,
                            value: valueInput.value
                        };
                    }
                });
                newConfig.badges.push(badge);
            });
            return newConfig;
        }
        
        function handleExportPlain() {
            const dataToExport = extractDataFromForm();
            delete dataToExport.issuer.privateKey;
            
            // Validate before export
            const validation = validateConfiguration(dataToExport);
            const statusDiv = document.getElementById('validation-status');
            if (validation.warnings.length > 0) {
                statusDiv.className = 'warning-message';
                statusDiv.innerHTML = `<strong>Export Warnings:</strong><br>${validation.warnings.join('<br>')}`;
                statusDiv.classList.remove('hidden');
            } else {
                statusDiv.classList.add('hidden');
            }
            
            triggerDownload(new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' }), 'config.json');
        }

        async function handleExportEncrypted() {
            const password = await promptForPassword('Create Encryption Password', true, true);
            if (!password) return;
            const dataToExport = extractDataFromForm();
            const iterations = parseInt(document.getElementById('kdf-iterations').value, 10);
            const encryptedFile = await encryptData(JSON.stringify(dataToExport), password, iterations);
            triggerDownload(new Blob([JSON.stringify(encryptedFile)], { type: 'application/json' }), 'config.encrypted.json');
        }

        function generateSingleJson(type, index) {
            const data = extractDataFromForm();
            let objectToShow = {};
            let filename = 'data.json';
            
            if (type === 'issuer') {
                const { privateKey, customFields, publicKey, profileUrl, publicKeyUrl, ...issuerData } = data.issuer;
                
                // Use profileUrl if provided, otherwise generate data URI
                const issuerId = profileUrl || generateDataUriId({ 
                    "@context": "https://w3id.org/openbadges/v2", 
                    type: "Profile", 
                    ...issuerData 
                });
                
                objectToShow = { 
                    "@context": "https://w3id.org/openbadges/v2", 
                    type: "Profile", 
                    id: issuerId,
                    ...issuerData 
                };
                
                if (publicKeyUrl) {
                    objectToShow.publicKey = publicKeyUrl;
                }
                
                if (customFields) {
                    for(const key in customFields) {
                        if (customFields[key].type === 'global') objectToShow[key] = customFields[key].value;
                    }
                }
                filename = 'issuer.json';
                
            } else if (type === 'publickey') {
                const publicKeyStr = data.issuer.publicKey;
                if (!publicKeyStr) {
                    alert("No public key found. Please generate a key pair first.");
                    return;
                }
                
                try {
                    const jwk = JSON.parse(publicKeyStr);
                    const pem = jwkToPem(jwk);
                    
                    objectToShow = {
                        "@context": "https://w3id.org/openbadges/v2",
                        type: "CryptographicKey",
                        id: data.issuer.publicKeyUrl || "https://yourdomain.com/badges/public-key.json",
                        owner: data.issuer.profileUrl || "https://yourdomain.com/badges/issuer.json",
                        publicKeyPem: pem
                    };
                    filename = 'public-key.json';
                } catch(e) {
                    alert("Error converting public key: " + e.message);
                    return;
                }
                
            } else if (type === 'badge' && data.badges[index]) {
                const { alias, customFields, ...badge } = data.badges[index];
                
                // First create the issuer reference
                let issuerRef;
                if (badge.issuerType === 'hosted' && data.issuer.profileUrl) {
                    issuerRef = data.issuer.profileUrl;
                } else {
                    // Embedded issuer
                    const { privateKey, publicKey, customFields: icf, profileUrl, publicKeyUrl, ...publicIssuerData } = data.issuer;
                    const issuerProfile = {
                        "@context": "https://w3id.org/openbadges/v2", 
                        type: "Profile", 
                        ...publicIssuerData
                    };
                    if (publicKeyUrl) issuerProfile.publicKey = publicKeyUrl;
                    if (icf) {
                        for(const key in icf) {
                            if (icf[key].type === 'global') issuerProfile[key] = icf[key].value;
                        }
                    }
                    issuerProfile.id = generateDataUriId(issuerProfile);
                    issuerRef = issuerProfile;
                }
                
                objectToShow = { 
                    "@context": "https://w3id.org/openbadges/v2", 
                    type: "BadgeClass", 
                    ...badge, 
                    criteria: { narrative: badge.criteria },
                    issuer: issuerRef
                };
                
                delete objectToShow.issuerType;
                delete objectToShow.image_base_64;
                objectToShow.image = badge.image_base_64;
                
                if (badge.tags) objectToShow.tags = badge.tags.split(',').map(t => t.trim());
                if (customFields) {
                    for(const key in customFields) {
                        if (customFields[key].type === 'global') objectToShow[key] = customFields[key].value;
                    }
                }
                
                objectToShow.id = generateDataUriId(objectToShow);
                filename = `badgeclass-${alias || 'badge'}.json`;
            }
            
            const modal = document.getElementById('json-viewer-modal');
            modal.innerHTML = document.getElementById('json-viewer-modal-template').innerHTML;
            const contentTextarea = document.getElementById('json-viewer-content');
            const downloadBtn = document.getElementById('json-download-btn');
            const closeBtn = document.getElementById('json-close-btn');
            const jsonString = JSON.stringify(objectToShow, null, 2);
            contentTextarea.value = jsonString;
            downloadBtn.onclick = () => triggerDownload(new Blob([jsonString], { type: 'application/json' }), filename);
            closeBtn.onclick = () => modal.classList.add('hidden');
            modal.classList.remove('hidden');
        }
        
        function generateDataUriId(obj) {
            // Remove id to avoid circular reference
            const {id, ...objWithoutId} = obj;
            const jsonString = JSON.stringify(objWithoutId);
            return `data:application/json;base64,${btoa(unescape(encodeURIComponent(jsonString)))}`;
        }
        
        function clearSession() {
            if (confirm("Are you sure? This will clear all data and lock the application.")) {
                window.location.reload();
            }
        }

        function promptForPassword(title, needsConfirmation = false, isEncrypting = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('password-modal');
                const modalTitle = modal.querySelector('#modal-title');
                const modalWarning = modal.querySelector('#modal-warning');
                const modalError = modal.querySelector('#modal-error');
                const modalPassword = modal.querySelector('#modal-password');
                const modalConfirmPassword = modal.querySelector('#modal-confirm-password');
                const modalSubmit = modal.querySelector('#modal-submit');
                const modalCancel = modal.querySelector('#modal-cancel');
                
                modalTitle.textContent = title;
                modalPassword.value = '';
                modalConfirmPassword.value = '';
                modalError.classList.add('hidden');
                modalConfirmPassword.classList.toggle('hidden', !needsConfirmation);
                modalWarning.classList.toggle('hidden', !isEncrypting);
                if (isEncrypting) {
                    modalWarning.textContent = "Warning: Use a strong, unique password. If you lose it, your encrypted file will be unrecoverable.";
                }
                modal.classList.remove('hidden');

                const submitHandler = () => {
                    const pass = modalPassword.value;
                    const confirmPass = modalConfirmPassword.value;
                    if (needsConfirmation && pass !== confirmPass) { displayError(modalError, "Passwords do not match."); return; }
                    if (!pass) { displayError(modalError, "Password cannot be empty."); return; }
                    cleanup();
                    resolve(pass);
                };
                const cancelHandler = () => { cleanup(); resolve(null); };
                const cleanup = () => {
                    modal.classList.add('hidden');
                    modalSubmit.removeEventListener('click', submitHandler);
                    modalCancel.removeEventListener('click', cancelHandler);
                };
                modalSubmit.addEventListener('click', submitHandler);
                modalCancel.addEventListener('click', cancelHandler);
            });
        }
        
        async function encryptData(text, password, iterations) {
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey(password, salt, iterations);
            const encryptedContent = await window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, new TextEncoder().encode(text));
            const now = new Date().toISOString();
            return {
                metadata: { 
                    createdAt: now, 
                    updatedAt: now, 
                    kdf: "PBKDF2", 
                    iterations: iterations,
                    version: CONFIG_VERSION 
                },
                encryptedData: { 
                    iv: Array.from(iv), 
                    salt: Array.from(salt), 
                    ciphertext: Array.from(new Uint8Array(encryptedContent)) 
                }
            };
        }

        async function decryptData(fileData, password) {
            const { iv, salt, ciphertext } = fileData.encryptedData;
            const iterations = fileData.metadata.iterations;
            const key = await deriveKey(password, new Uint8Array(salt), iterations);
            const decryptedContent = await window.crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, key, new Uint8Array(ciphertext));
            return new TextDecoder().decode(decryptedContent);
        }

        async function deriveKey(password, salt, iterations) {
            const keyMaterial = await window.crypto.subtle.importKey('raw', new TextEncoder().encode(password), { name: 'PBKDF2' }, false, ['deriveKey']);
            return window.crypto.subtle.deriveKey({ name: 'PBKDF2', salt: salt, iterations: iterations, hash: 'SHA-256' }, keyMaterial, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']);
        }
        
        function triggerDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function populateBadgeSelector(badges) {
            const badgeSelect = document.getElementById('badge-select');
            if (!badgeSelect) return;
            badgeSelect.innerHTML = '<option value="" disabled selected>-- Select a Badge --</option>';
            badges.forEach(badge => {
                const option = document.createElement('option');
                option.value = badge.alias;
                option.textContent = `${badge.name} (${badge.alias})`;
                badgeSelect.appendChild(option);
            });
        }
        
        function updateBakeForm() {
            const badgeSelect = document.getElementById('badge-select');
            const dynamicFieldsContainer = document.getElementById('dynamic-bake-fields');
            dynamicFieldsContainer.innerHTML = '';
            
            const selectedAlias = badgeSelect.value;
            if (!selectedAlias || !config) return;

            const badge = config.badges.find(b => b.alias === selectedAlias);
            if (badge && badge.customFields) {
                for (const key in badge.customFields) {
                    const field = badge.customFields[key];
                    if (field.type.startsWith('baking-')) {
                        const div = document.createElement('div');
                        div.className = 'dynamic-bake-field';
                        const isRequired = field.type === 'baking-required';
                        
                        let inputHTML = `<input type="text" id="bake-custom-${key}" data-key="${key}" ${isRequired ? 'required' : ''}>`;
                        if (!isRequired) {
                            inputHTML += `<button type="button" class="danger">X</button>`;
                        }
                        
                        div.innerHTML = `
                            <label for="bake-custom-${key}">${key}${isRequired ? ' *' : ''}</label>
                            ${inputHTML}
                        `;
                        dynamicFieldsContainer.appendChild(div);

                        if (!isRequired) {
                            div.querySelector('.danger').addEventListener('click', () => div.remove());
                        }
                    }
                }
            }
            
            updateSigningCapability();
        }

        function attachDynamicListeners() {
            document.getElementById('baker-form').addEventListener('submit', handleBake);
            document.getElementById('badge-select').addEventListener('change', updateBakeForm);
            document.getElementById('validate-before-bake').addEventListener('click', validateBeforeBake);
            document.getElementById('validate-result-btn').addEventListener('click', validateBakedBadge);
            document.querySelectorAll('input[name="expiration"]').forEach(radio => radio.addEventListener('change', (e) => {
                document.getElementById('expires-date').classList.toggle('hidden', e.target.value === 'no');
            }));
            document.getElementById('verifyFile').addEventListener('change', handleVerifyFile);
            document.getElementById('verifyIssuerFile').addEventListener('change', (e) => handleJsonFileUpload(e, 'verifyIssuerText'));
            document.getElementById('verifyBadgeFile').addEventListener('change', (e) => handleJsonFileUpload(e, 'verifyBadgeText'));
            document.getElementById('verify-recipient-btn').addEventListener('click', handleVerifyRecipient);
            document.getElementById('toggle-json-btn').addEventListener('click', () => {
                document.getElementById('verify-output').classList.toggle('hidden');
            });
            document.getElementById('issued-date').valueAsDate = new Date();
        }
        
        function handleJsonFileUpload(event, textareaId) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById(textareaId).value = e.target.result;
            };
            reader.readAsText(file);
        }

        async function validateBeforeBake() {
            const badgeAlias = document.getElementById('badge-select').value;
            if (!badgeAlias) {
                alert('Please select a badge first.');
                return;
            }
            
            try {
                const recipientEmail = document.getElementById('recipient-email').value || "test@example.com";
                const issuedDate = document.getElementById('issued-date').value || new Date().toISOString().split('T')[0];
                const verificationType = document.querySelector('input[name="verification"]:checked').value;
                
                const badgeData = config.badges.find(b => b.alias === badgeAlias);
                const assertion = await buildAssertion(badgeData, recipientEmail, issuedDate, null, '', verificationType, {});
                
                // Basic validation
                const errors = validateBadgeStructure(assertion);
                if (errors.length > 0) {
                    alert(`Validation Errors:\n${errors.join('\n')}`);
                } else {
                    alert('Badge structure is valid! Ready to bake.');
                }
            } catch (e) {
                alert(`Validation failed: ${e.message}`);
            }
        }

        async function validateBakedBadge() {
            const resultDiv = document.getElementById('validation-result');
            const imgSrc = document.getElementById('preview-img').src;
            
            resultDiv.innerHTML = '<div class="info-message">Validating badge structure...</div>';
            resultDiv.classList.remove('hidden');
            
            try {
                // Extract badge from PNG
                const response = await fetch(imgSrc);
                const blob = await response.blob();
                const arrayBuffer = await blob.arrayBuffer();
                const pngBytes = new Uint8Array(arrayBuffer);
                
                const result = extractBadgeData(pngBytes);
                if (!result || !result.assertion) {
                    displayError(resultDiv, 'No badge data found in image.');
                    return;
                }
                
                const errors = validateBadgeStructure(result.assertion);
                if (errors.length === 0) {
                    displaySuccess(resultDiv, '‚úÖ Badge structure is valid according to Open Badges 2.0 specification!');
                } else {
                    displayError(resultDiv, `‚ùå Validation Errors:\n${errors.join('\n')}`);
                }
            } catch (e) {
                displayError(resultDiv, `Validation error: ${e.message}`);
            }
        }

        function validateBadgeStructure(assertion) {
            const errors = [];
            
            // Check assertion structure
            if (!assertion['@context'] || assertion['@context'] !== 'https://w3id.org/openbadges/v2') {
                errors.push('Assertion: Missing or invalid @context');
            }
            if (!assertion.type || assertion.type !== 'Assertion') {
                errors.push('Assertion: Missing or invalid type');
            }
            if (!assertion.recipient) errors.push('Assertion: Missing recipient');
            if (!assertion.badge) errors.push('Assertion: Missing badge');
            if (!assertion.issuedOn) errors.push('Assertion: Missing issuedOn');
            if (!assertion.verification) errors.push('Assertion: Missing verification');
            if (!assertion.id) errors.push('Assertion: Missing id');
            
            // Check badge class structure
            if (assertion.badge) {
                const badge = assertion.badge;
                if (!badge['@context']) errors.push('BadgeClass: Missing @context');
                if (!badge.type || badge.type !== 'BadgeClass') errors.push('BadgeClass: Missing or invalid type');
                if (!badge.id) errors.push('BadgeClass: Missing id');
                if (!badge.name) errors.push('BadgeClass: Missing name');
                if (!badge.description) errors.push('BadgeClass: Missing description');
                if (!badge.image) errors.push('BadgeClass: Missing image');
                if (!badge.criteria) errors.push('BadgeClass: Missing criteria');
                if (!badge.issuer) errors.push('BadgeClass: Missing issuer');
                
                // Check issuer structure
                if (badge.issuer) {
                    const issuer = typeof badge.issuer === 'string' ? null : badge.issuer;
                    if (issuer) {
                        if (!issuer['@context']) errors.push('Issuer: Missing @context');
                        if (!issuer.type || issuer.type !== 'Profile') errors.push('Issuer: Missing or invalid type');
                        if (!issuer.id) errors.push('Issuer: Missing id');
                        if (!issuer.name) errors.push('Issuer: Missing name');
                        if (!issuer.url) errors.push('Issuer: Missing url');
                    }
                }
            }
            
            return errors;
        }

        function validateConfiguration(config) {
            const warnings = [];
            
            if (!config.issuer.profileUrl) {
                warnings.push("No issuer profile URL specified. Signed badges will not work without hosting.");
            }
            if (!config.issuer.publicKeyUrl) {
                warnings.push("No public key URL specified. Signed badges will not work without hosting.");
            }
            
            config.badges.forEach((badge, i) => {
                if (badge.issuerType === 'hosted' && !config.issuer.profileUrl) {
                    warnings.push(`Badge ${i+1}: Hosted issuer type requires issuer profile URL.`);
                }
            });
            
            return { warnings };
        }

        async function handleBake(event) {
            event.preventDefault();
            const bakerError = document.getElementById('baker-error');
            const resultSection = document.getElementById('result-section');
            bakerError.classList.add('hidden');
            resultSection.classList.add('hidden');

            const badgeAlias = document.getElementById('badge-select').value;
            const recipientEmail = document.getElementById('recipient-email').value;
            const evidenceUrl = document.getElementById('evidence-url').value;
            const issuedDate = document.getElementById('issued-date').value;
            const expiresOption = document.querySelector('input[name="expiration"]:checked').value;
            const expiresDate = expiresOption === 'yes' ? document.getElementById('expires-date').value : null;
            const verificationType = document.querySelector('input[name="verification"]:checked').value;

            if (!badgeAlias) {
                displayError(bakerError, 'You must select a badge to bake.');
                return;
            }

            const bakeTimeCustomFields = {};
            document.querySelectorAll('#dynamic-bake-fields .dynamic-bake-field').forEach(field => {
                const input = field.querySelector('input[type="text"]');
                if (input.value) {
                    bakeTimeCustomFields[input.dataset.key] = input.value;
                }
            });

            const issuerData = extractDataFromForm().issuer;
            if (verificationType === 'signed' && !issuerData.privateKey) {
                displayError(bakerError, 'A private key must be provided in Issuer Management to create a signed badge.');
                return;
            }

            try {
                const badgeData = config.badges.find(b => b.alias === badgeAlias);
                const assertion = await buildAssertion(badgeData, recipientEmail, issuedDate, expiresDate, evidenceUrl, verificationType, bakeTimeCustomFields);
                const isSigned = verificationType === 'signed';
                const bakedPngDataUri = await bakePng(badgeData.image_base_64, assertion, isSigned);
                
                let displayAssertion = assertion;
                if (isSigned) {
                    try {
                        displayAssertion = JSON.parse(atob(assertion.split('.')[1].replace(/-/g, '+').replace(/_/g, '/')));
                    } catch(e) { /* leave as JWS if decode fails */ }
                }
                
                document.getElementById('json-output').textContent = JSON.stringify(displayAssertion, null, 2);
                document.getElementById('preview-img').src = bakedPngDataUri;
                const downloadLink = document.getElementById('download-link');
                downloadLink.href = bakedPngDataUri;
                downloadLink.download = `${badgeAlias}-${recipientEmail.split('@')[0]}.png`;
                resultSection.classList.remove('hidden');
            } catch (error) {
                displayError(bakerError, `Could not bake badge: ${error.message}`);
            }
        }

        async function createJws(payload, privateKeyJwk) {
            const header = { alg: "ES256", typ: "JWT" };
            const toBase64Url = (data) => btoa(unescape(encodeURIComponent(data))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
            const encodedHeader = toBase64Url(JSON.stringify(header));
            const encodedPayload = toBase64Url(JSON.stringify(payload));
            const dataToSign = new TextEncoder().encode(`${encodedHeader}.${encodedPayload}`);
            
            const privateKey = await window.crypto.subtle.importKey("jwk", privateKeyJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["sign"]);
            const signature = await window.crypto.subtle.sign({ name: "ECDSA", hash: { name: "SHA-256" } }, privateKey, dataToSign);
            const encodedSignature = toBase64Url(String.fromCharCode(...new Uint8Array(signature)));
            return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
        }
        
        async function buildAssertion(badge, email, issuedOn, expires, evidence, verificationType, bakeTimeCustomFields) {
            const recipientIdentity = await hashRecipient(email);
            const issuerData = extractDataFromForm().issuer;
            
            const { privateKey, publicKey, customFields: issuerCustomFields, profileUrl, publicKeyUrl, ...publicIssuerData } = issuerData;
            const { alias, customFields: badgeCustomFields, ...badgeProps } = badge;
            
            // Build issuer profile
            let issuerProfile = { 
                "@context": "https://w3id.org/openbadges/v2", 
                type: "Profile", 
                ...publicIssuerData 
            };
            
            if (issuerCustomFields) {
                for (const key in issuerCustomFields) {
                    if (issuerCustomFields[key].type === 'global') issuerProfile[key] = issuerCustomFields[key].value;
                }
            }
            
            // Set issuer ID based on whether it's hosted or embedded
            if (profileUrl && badge.issuerType === 'hosted') {
                issuerProfile.id = profileUrl;
                if (publicKeyUrl) issuerProfile.publicKey = publicKeyUrl;
            } else {
                // Embedded issuer - use data URI
                issuerProfile.id = generateDataUriId(issuerProfile);
            }

            // Build badge class
            let badgeClass = { 
                ...badgeProps, 
                "@context": "https://w3id.org/openbadges/v2", 
                type: "BadgeClass", 
                criteria: { narrative: badge.criteria }, 
                image: badge.image_base_64 
            };
            
            delete badgeClass.image_base_64;
            delete badgeClass.issuerType;
            
            // Set issuer reference
            if (badge.issuerType === 'hosted' && profileUrl) {
                badgeClass.issuer = profileUrl;
            } else {
                badgeClass.issuer = issuerProfile;
            }
            
            if (badge.tags) badgeClass.tags = badge.tags.split(',').map(t => t.trim());
            if (badgeCustomFields) {
                for (const key in badgeCustomFields) {
                    if (badgeCustomFields[key].type === 'global') badgeClass[key] = badgeCustomFields[key].value;
                }
            }
            
            badgeClass.id = generateDataUriId(badgeClass);

            // Build assertion
            let assertion = {
                "@context": "https://w3id.org/openbadges/v2",
                type: "Assertion",
                recipient: recipientIdentity,
                badge: badgeClass,
                issuedOn: new Date(`${issuedOn}T00:00:00Z`).toISOString(),
                ...bakeTimeCustomFields
            };
            
            if (expires) assertion.expires = new Date(`${expires}T00:00:00Z`).toISOString();
            if (evidence) assertion.evidence = { id: evidence };
            
            if (verificationType === 'embedded') {
                assertion.id = generateDataUriId(assertion);
                assertion.verification = { type: "HostedBadge" };
                return assertion;
            } else { // signed
                if (!publicKeyUrl) {
                    throw new Error("Public key URL is required for signed badges");
                }
                assertion.verification = { 
                    type: "SignedBadge", 
                    creator: publicKeyUrl 
                };
                const privateKeyJwk = JSON.parse(privateKey);
                return createJws(assertion, privateKeyJwk);
            }
        }

        async function handleVerifyFile(event) {
            const file = event.target.files[0];
            if (!file || file.type !== 'image/png') {
                displayError(document.getElementById('verify-error'), "Invalid file type. Please upload a PNG image.");
                return;
            }
            const verifyError = document.getElementById('verify-error');
            const verifySummary = document.getElementById('verify-summary');
            const verifyOutput = document.getElementById('verify-output');
            verifyError.classList.add('hidden');
            verifySummary.classList.add('hidden');
            verifyOutput.classList.add('hidden');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const pngBytes = new Uint8Array(e.target.result);
                    const result = extractBadgeData(pngBytes);
                    if (result && result.assertion) {
                        currentAssertionData = result.assertion;
                        
                        const issuerJsonText = document.getElementById('verifyIssuerText').value;
                        const badgeJsonText = document.getElementById('verifyBadgeText').value;
                        
                        await displayVerificationSummary(result.assertion, result.isSigned, result.jws, issuerJsonText, badgeJsonText);
                        verifyOutput.textContent = JSON.stringify(result.assertion, null, 2);
                        verifySummary.classList.remove('hidden');
                    } else {
                        verifyOutput.textContent = 'No valid Open Badge metadata found.';
                        verifyOutput.classList.remove('hidden');
                    }
                } catch (error) {
                    displayError(verifyError, `Error reading badge: ${error.message}`);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        async function displayVerificationSummary(assertion, isSigned, jws, issuerJsonText, badgeJsonText) {
            let manualIssuer = null, manualBadge = null;
            try { if(issuerJsonText) manualIssuer = JSON.parse(issuerJsonText); } catch(e) { displayError(document.getElementById('verify-error'), "Invalid Issuer JSON provided."); }
            try { if(badgeJsonText) manualBadge = JSON.parse(badgeJsonText); } catch(e) { displayError(document.getElementById('verify-error'), "Invalid BadgeClass JSON provided."); }

            let finalAssertion = { ...assertion };
            if (manualBadge) {
                finalAssertion.badge = manualBadge;
            }
            if (typeof finalAssertion.badge.issuer === 'string' && manualIssuer) {
                finalAssertion.badge.issuer = manualIssuer;
            }

            const fieldMap = {
                badge: { label: 'Badge Details', fields: { 'name': 'Name', 'description': 'Description', 'image': 'Image', 'criteria.narrative': 'Criteria' } },
                issuer: { label: 'Issuer Details', fields: { 'name': 'Name', 'url': 'URL', 'id': 'Profile URL', 'image': 'Logo' } },
                recipient: { label: 'Recipient', fields: { 'identity': 'Identity', 'hashed': 'Hashed', 'salt': 'Salt', 'type': 'Type' } },
                assertion: { label: 'Assertion Details', fields: { 'issuedOn': 'Issued On', 'expires': 'Expires', 'id': 'ID', 'evidence.id': 'Evidence' } }
            };

            let tableHTML = `<table class="summary-table">`;
            for (const section in fieldMap) {
                const sourceObject = section === 'assertion' ? finalAssertion : getNested(finalAssertion, section);
                if (!sourceObject) continue;
                
                tableHTML += `<tr><th colspan="2"><h4>${fieldMap[section].label}</h4></th></tr>`;
                for(const key in fieldMap[section].fields) {
                    const value = getNested(sourceObject, key);
                    if (value !== undefined && value !== null) {
                        const label = fieldMap[section].fields[key];
                        let renderedValue = escapeHtml(value.toString());
                        if ((key.endsWith('image') || key.endsWith('image_base_64')) && value.startsWith('data:image')) {
                            renderedValue = `<img src="${value}" alt="${label} preview" class="summary-image">`;
                        } else if (key.endsWith('On') || key === 'expires') {
                           try { renderedValue = new Date(value).toUTCString(); } catch(e){}
                        } else if (key === 'identity') {
                            renderedValue = `<span title="${value}">${value.substring(0, 50)}...</span>`;
                        }
                        tableHTML += `<tr><th>${label}</th><td>${renderedValue}</td></tr>`;
                    }
                }
            }
            
            let verificationStatus = { signature: '‚ö™ Not Applicable' };
            if (isSigned) {
                verificationStatus.signature = '‚åõ Verifying...';
            }
            
            tableHTML += `<tr><th colspan="2"><h4>Verification Status</h4></th></tr>`;
            tableHTML += `<tr><th>Signature Status</th><td id="status-signature">${verificationStatus.signature}</td></tr>`;
            tableHTML += `</table>`;
            
            const summaryTableDiv = document.getElementById('verify-summary-table');
            summaryTableDiv.innerHTML = tableHTML;

            summaryTableDiv.querySelectorAll('.summary-image').forEach(img => {
                img.addEventListener('click', (e) => showImageModal(e.target.src));
            });

            document.getElementById('recipient-verification-section').classList.remove('hidden');

            if (isSigned) {
                const publicKeyUrl = assertion.verification?.creator;
                let publicKeyJwk = null;
                
                // Try to get public key from manual issuer first
                if (manualIssuer && manualIssuer.publicKey) {
                    // If publicKey is a URL, we'd need to fetch it
                    // For now, assume it's embedded JWK
                    try {
                        publicKeyJwk = typeof manualIssuer.publicKey === 'string' ? 
                            JSON.parse(manualIssuer.publicKey) : manualIssuer.publicKey;
                    } catch(e) {}
                }
                
                if(publicKeyJwk) {
                    const verifyResult = await verifyJws(jws, publicKeyJwk);
                    document.getElementById('status-signature').textContent = verifyResult.success ? '‚úÖ Verified' : `‚ùå Invalid Signature (${verifyResult.reason})`;
                } else {
                    document.getElementById('status-signature').textContent = `‚ö†Ô∏è Public Key not provided. Would need to fetch from: ${publicKeyUrl || 'unknown'}`;
                }
            }
        }
        
        function getNested(obj, path) {
            return path.split('.').reduce((o, key) => (o && o[key] !== undefined ? o[key] : undefined), obj);
        }
        
        function showImageModal(src) {
            const modal = document.getElementById('image-viewer-modal');
            modal.innerHTML = document.getElementById('image-viewer-modal-template').innerHTML;
            modal.querySelector('#image-viewer-img').src = src;
            const downloadLink = modal.querySelector('#image-download-link');
            downloadLink.href = src;
            downloadLink.download = 'badge-image.png';
            modal.querySelector('#image-close-btn').onclick = () => modal.classList.add('hidden');
            modal.classList.remove('hidden');
        }
        
        async function verifyJws(jws, publicKeyJwk) {
            try {
                const parts = jws.split('.');
                if (parts.length !== 3) return { success: false, reason: 'Invalid JWS format' };
                if (!publicKeyJwk) return { success: false, reason: 'Public key not provided' };
                
                const publicKey = await window.crypto.subtle.importKey("jwk", publicKeyJwk, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
                
                const dataToVerify = new TextEncoder().encode(`${parts[0]}.${parts[1]}`);
                const signature = new Uint8Array(atob(parts[2].replace(/-/g, '+').replace(/_/g, '/')).split('').map(c => c.charCodeAt(0)));
                
                const isValid = await window.crypto.subtle.verify({ name: "ECDSA", hash: { name: "SHA-256" } }, publicKey, signature, dataToVerify);
                return { success: isValid, reason: isValid ? 'OK' : 'Signature mismatch' };
            } catch (e) {
                console.error("JWS Verification failed:", e);
                return { success: false, reason: e.message };
            }
        }

        async function handleVerifyRecipient() {
            if (!currentAssertionData) return;
            const emailToVerify = document.getElementById('verify-email-input').value;
            const recipientVerificationResult = document.getElementById('recipient-verification-result');
            if (!emailToVerify) {
                recipientVerificationResult.textContent = "Please enter an email to verify.";
                return;
            }
            try {
                const { salt, identity } = currentAssertionData.recipient;
                if (!salt || !identity) throw new Error("Recipient data is incomplete.");
                const expectedHash = identity.split('$')[1] || identity;
                const newHash = (await hashRecipient(emailToVerify, salt)).identity.split('$')[1];
                if (newHash === expectedHash) {
                    recipientVerificationResult.textContent = `‚úÖ Verified for: ${escapeHtml(emailToVerify)}`;
                    recipientVerificationResult.style.color = 'green';
                } else {
                    recipientVerificationResult.textContent = `‚ùå Verification failed for: ${escapeHtml(emailToVerify)}`;
                    recipientVerificationResult.style.color = 'red';
                }
            } catch (e) {
                recipientVerificationResult.textContent = `Could not perform verification: ${e.message}`;
                recipientVerificationResult.style.color = 'red';
            }
        }
        
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        async function hashRecipient(email, salt = `salt-${Date.now()}`) {
            const identityStr = email + salt;
            const data = new TextEncoder().encode(identityStr);
            const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return { type: 'email', hashed: true, salt: salt, identity: `sha256$${hashArray.map(b => b.toString(16).padStart(2, '0')).join('')}` };
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0; return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // JWK to PEM conversion for public key
        function jwkToPem(jwk) {
            if (jwk.kty !== 'EC' || jwk.crv !== 'P-256') {
                throw new Error('Only P-256 EC keys are supported');
            }
            
            // Convert base64url to base64
            const toBase64 = (base64url) => {
                return base64url.replace(/-/g, '+').replace(/_/g, '/') + 
                    '=='.substring(0, (4 - base64url.length % 4) % 4);
            };
            
            // Create uncompressed point (0x04 + x + y)
            const xBytes = atob(toBase64(jwk.x));
            const yBytes = atob(toBase64(jwk.y));
            const point = String.fromCharCode(0x04) + xBytes + yBytes;
            
            // Create SubjectPublicKeyInfo structure
            const algorithmIdentifier = atob('MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE');
            const publicKeyBytes = algorithmIdentifier + point;
            
            // Base64 encode and format as PEM
            const base64 = btoa(publicKeyBytes);
            const pem = '-----BEGIN PUBLIC KEY-----\n' +
                base64.match(/.{1,64}/g).join('\n') +
                '\n-----END PUBLIC KEY-----';
            
            return pem;
        }
        
        function extractBadgeData(pngBytes) {
            const decoder = new TextDecoder(); let offset = 8;
            while (offset < pngBytes.length) {
                const view = new DataView(pngBytes.buffer);
                const len = view.getUint32(offset, false);
                const type = decoder.decode(pngBytes.slice(offset + 4, offset + 8));
                if ((type === 'tEXt' || type === 'iTXt') && len > 10) {
                    const chunkData = pngBytes.slice(offset + 8, offset + 8 + len);
                    const nullIndex = chunkData.indexOf(0);
                    if (nullIndex > 0) {
                        const keyword = decoder.decode(chunkData.slice(0, nullIndex));
                        if (keyword === 'openbadges') {
                            let dataOffset = nullIndex + 1;
                            if (type === 'iTXt') { 
                                if (chunkData[dataOffset] === 0 && chunkData[dataOffset+1] === 0) {
                                    dataOffset += 4;
                                } else { 
                                    dataOffset += 2; while (dataOffset < chunkData.length && chunkData[dataOffset] !== 0) dataOffset++; dataOffset++; while (dataOffset < chunkData.length && chunkData[dataOffset] !== 0) dataOffset++; dataOffset++; 
                                }
                            }
                            const assertionText = decoder.decode(chunkData.slice(dataOffset));
                            const isSigned = assertionText.split('.').length === 3 && assertionText.startsWith('ey');
                            let assertion;
                            if (isSigned) {
                                try { assertion = JSON.parse(atob(assertionText.split('.')[1].replace(/-/g, '+').replace(/_/g, '/'))); }
                                catch (e) { assertion = { error: "Could not decode JWS payload", jws: assertionText }; }
                            } else {
                                assertion = JSON.parse(assertionText);
                            }
                            return { assertion, isSigned, jws: isSigned ? assertionText : null };
                        }
                    }
                }
                if (type === 'IEND') break;
                offset += 12 + len;
            }
            return { assertion: null };
        }

        async function bakePng(base64Png, assertion, isSigned) {
            const pngHeader = "data:image/png;base64,";
            if (!base64Png || !base64Png.startsWith(pngHeader)) {
                throw new Error("Invalid or missing base64 PNG data for baking.");
            }
            const pngData = atob(base64Png.substring(pngHeader.length));
            const pngBytes = new Uint8Array(pngData.length);
            for (let i = 0; i < pngData.length; i++) pngBytes[i] = pngData.charCodeAt(i);
            
            const keyword = "openbadges"; 
            const text = isSigned ? assertion : JSON.stringify(assertion);
            const encoder = new TextEncoder();
            const keywordBytes = encoder.encode(keyword); const textBytes = encoder.encode(text);

            const iTXtChunkData = new Uint8Array(keywordBytes.length + 5 + textBytes.length);
            let i = 0;
            iTXtChunkData.set(keywordBytes, i); i+= keywordBytes.length;
            iTXtChunkData[i++] = 0; // Null separator for keyword
            iTXtChunkData[i++] = 0; // Compression flag: 0 (not compressed)
            iTXtChunkData[i++] = 0; // Compression method: 0 (zlib)
            iTXtChunkData[i++] = 0; // Language tag: null
            iTXtChunkData[i++] = 0; // Translated keyword: null
            iTXtChunkData.set(textBytes, i);
            
            const chunkType = new Uint8Array([105, 84, 88, 116]); // iTXt
            const chunkLength = iTXtChunkData.length;
            const fullChunk = new Uint8Array(4 + 4 + chunkLength + 4);
            const view = new DataView(fullChunk.buffer);
            view.setUint32(0, chunkLength, false);
            fullChunk.set(chunkType, 4); fullChunk.set(iTXtChunkData, 8);
            const crcData = new Uint8Array(4 + chunkLength);
            crcData.set(chunkType, 0); crcData.set(iTXtChunkData, 4);
            view.setUint32(8 + chunkLength, crc32(crcData), false);
            
            let iendOffset = -1;
            for (let i = 8; i < pngBytes.length;) {
                const len = (new DataView(pngBytes.buffer)).getUint32(i, false);
                const type = new TextDecoder().decode(pngBytes.slice(i + 4, i + 8));
                if (type === 'IEND') { iendOffset = i; break; }
                i += 12 + len;
            }
            if (iendOffset === -1) throw new Error("Could not find IEND chunk in PNG.");

            const newPngBytes = new Uint8Array(pngBytes.length + fullChunk.length);
            newPngBytes.set(pngBytes.slice(0, iendOffset), 0);
            newPngBytes.set(fullChunk, iendOffset);
            newPngBytes.set(pngBytes.slice(iendOffset), iendOffset + fullChunk.length);
            
            let newPngData = '';
            for (let i = 0; i < newPngBytes.length; i++) newPngData += String.fromCharCode(newPngBytes[i]);
            return pngHeader + btoa(newPngData);
        }

        const crcTable = (() => {
            const table = new Int32Array(256);
            for(let n = 0; n < 256; n++) { let c = n; for(let k = 0; k < 8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1)); table[n] = c; }
            return table;
        })();
        function crc32(bytes) {
            let crc = -1;
            for (let i = 0; i < bytes.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
            return (crc ^ -1) >>> 0;
        }

        async function autoLoadConfig() {
            try {
                const encryptedResponse = await fetch('config.encrypted.json');
                if (encryptedResponse.ok) {
                    const encryptedContent = await encryptedResponse.text();
                    await processUploadedConfig(encryptedContent);
                    return; 
                }
            } catch (e) { /* Fall through to plain config */ }
            
            try {
                const plainResponse = await fetch('config.json');
                if (plainResponse.ok) {
                    const plainContent = await plainResponse.text();
                    await processUploadedConfig(plainContent);
                }
            } catch (e) {
                console.error("Could not auto-load any config file:", e);
            }
        }
        autoLoadConfig();

    });
    </script>
</body>
</html>
